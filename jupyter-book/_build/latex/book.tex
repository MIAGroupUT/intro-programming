%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Manual}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Manual Introduction to Programming}
\date{Feb 13, 2024}
\release{}
\author{Jelmer Wolterink}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
This is the manual for the \sphinxstyleemphasis{Introduction to programming} part of Module 3 of the Technical Medicine program at the University of Twente. A deep understanding of programming is very useful, not just for passing this course or module, but for all the other courses and projects that you will work on in your \sphinxstyleemphasis{Technical Medicine} program and \sphinxhyphen{} likely \sphinxhyphen{} in your working life.

\sphinxAtStartPar
In part, this manual follows the previous manual for Matlab that was previously used in Technical Medicine, In other parts, it focuses on aspects that are specific to Python. This manual by no means claims to be a complete handbook to Python. For that, other options are available. Instead, it provides a summary of Python knowledge that will be relevant to the starting Technical Medicine student.

\sphinxAtStartPar
The manual consists of ten chapters. In each chapter, there are exercises, which you can recognize by their distinct appearance.

\begin{sphinxadmonition}{note}{Exercise}

\sphinxAtStartPar
This is an exercise.
\end{sphinxadmonition}

\sphinxAtStartPar
If you’re a student in the \sphinxstyleemphasis{Introduction to programming} course, you’re expected to complete all these exercises to pass the course.

\sphinxAtStartPar
The contents of this manual were carefully prepared by Jelmer Wolterink and Veerle Michels. If you find errors in the manual, please send an e\sphinxhyphen{}mail to \sphinxcode{\sphinxupquote{j.m.wolterink@utwente.nl}} so that they can be corrected.

\sphinxstepscope


\part{Manual}

\sphinxstepscope


\chapter{Introduction to programming}
\label{\detokenize{frontmatter/preface:introduction-to-programming}}\label{\detokenize{frontmatter/preface::doc}}
\sphinxAtStartPar
This is the manual for the \sphinxstyleemphasis{Introduction to programming} part of Module 3 of the Technical Medicine program at the University of Twente. A deep understanding of programming is very useful, not just for passing this course or module, but for all the other courses and projects that you will work on in your \sphinxstyleemphasis{Technical Medicine} program and \sphinxhyphen{} likely \sphinxhyphen{} in your working life.

\sphinxAtStartPar
In part, this manual follows the previous manual for Matlab that was previously used in Technical Medicine, In other parts, it focuses on aspects that are specific to Python. This manual by no means claims to be a complete handbook to Python. For that, other options are available. Instead, it provides a summary of Python knowledge that will be relevant to the starting Technical Medicine student.

\sphinxAtStartPar
The manual consists of ten chapters. In each chapter, there are exercises, which you can recognize by their distinct appearance.

\begin{sphinxadmonition}{note}{Exercise}

\sphinxAtStartPar
This is an exercise.
\end{sphinxadmonition}

\sphinxAtStartPar
If you’re a student in the \sphinxstyleemphasis{Introduction to programming} course, you’re expected to complete all these exercises to pass the course.

\sphinxAtStartPar
The contents of this manual were carefully prepared by Jelmer Wolterink and Veerle Michels. If you find errors in the manual, please send an e\sphinxhyphen{}mail to \sphinxcode{\sphinxupquote{j.m.wolterink@utwente.nl}} so that they can be corrected.

\sphinxstepscope


\chapter{Getting started}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:getting-started}}\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
be able to install and use Anaconda as your Python distribution

\item {} 
\sphinxAtStartPar
understand the role of the Python interpreter in programming

\item {} 
\sphinxAtStartPar
find and use the command line interface on your computer

\item {} 
\sphinxAtStartPar
perform basic operations using the Python interpreter

\item {} 
\sphinxAtStartPar
define variables in Python

\item {} 
\sphinxAtStartPar
work with floating point numbers, integers, string and boolean variables

\item {} 
\sphinxAtStartPar
write a Python script using Visual Studio Code

\item {} 
\sphinxAtStartPar
execute a Python script

\end{itemize}
\end{sphinxadmonition}


\section{What is Python?}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:what-is-python}}
\sphinxAtStartPar
Python is a programming language that allows you to write software programs. By programming in Python you can tell the computer how to do things. Just like Python, there are many other programming languages out there. You might have heard about some of them, like \sphinxcode{\sphinxupquote{C}}, \sphinxcode{\sphinxupquote{C++}}, \sphinxcode{\sphinxupquote{Java}}. Alternatively, it might be that you have heard of (or used) \sphinxcode{\sphinxupquote{Matlab}}. In general, programming languages have a lot of similarities. They all allow you to work with data such as information provided by the user or stored in a file, and do something based on that input. They (almost) all have ways to visualize results. Of course, there are also differences. Languages differ in the way that your code is \sphinxstyleemphasis{executed} on the computer, in the \sphinxstyleemphasis{syntax} that you should use when writing code, in naming conventions, etc. We use Python here because it is a widely used language that is user\sphinxhyphen{}friendly and allows you to get a grasp of fundamental concepts in programming.

\begin{sphinxadmonition}{note}{Python}

\sphinxAtStartPar
Python is an interpreted, object\sphinxhyphen{}oriented, high\sphinxhyphen{}level programming language with dynamic semantics.
\end{sphinxadmonition}

\sphinxAtStartPar
Python is a high\sphinxhyphen{}level language, which means that it is easy for humans to read and write Python. The fact that it is an interpreted language means that code does not have to be compiled before running: the interpreter will simply go over the lines in your code and execute them. This also means that code might run a bit slower than in a compiled language like \sphinxcode{\sphinxupquote{C++}}. It is also important to realize that Python is \sphinxstyleemphasis{object\sphinxhyphen{}oriented} and that everything in Python is an object. We will explain later what this means.


\section{How do I start?}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:how-do-i-start}}
\sphinxAtStartPar
Python is a programming language that doesn’t natively come with a programming environment. There are many ways to install and use Python on your own computer. In this first session we will use two essential components to get you up and running with Python.
\begin{itemize}
\item {} 
\sphinxAtStartPar
We will use \sphinxstylestrong{Anaconda} as the Python distribution and package manager.

\item {} 
\sphinxAtStartPar
We will use \sphinxstylestrong{Visual Studio Code} (VS Code) as the programming environment.

\end{itemize}

\sphinxAtStartPar
We’ll introduce all these tools step\sphinxhyphen{}by\sphinxhyphen{}step so that you get a good understanding what everything is and that you’ll be comfortable using Python.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Whenever we provide instructions on how to install software, please closely follow the order indicated.
\end{sphinxadmonition}


\section{Installing Anaconda}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:installing-anaconda}}
\sphinxAtStartPar
The first step is to download Anaconda, a widely used Python distribution. Anaconda contains a lot of very useful functionality including
\begin{itemize}
\item {} 
\sphinxAtStartPar
The newest versions of Python and many useful packages

\item {} 
\sphinxAtStartPar
A powerful package manager

\item {} 
\sphinxAtStartPar
A clean way to organize \sphinxstyleemphasis{environments}

\item {} 
\sphinxAtStartPar
A terminal

\end{itemize}

\sphinxAtStartPar
Anaconda is free. To download it, go to \sphinxhref{https://www.anaconda.com/download}{the Anaconda website} and select \sphinxcode{\sphinxupquote{Download}}. This will download a file of around 500MB\sphinxhyphen{}1GB. Use the file to install Anaconda. Follow the instructions and just install it as a regular software package. You can follow the detailed instructions \sphinxhref{https://docs.anaconda.com/free/anaconda/install/windows/}{here}. It’s important that you \sphinxstyleemphasis{don’t add Anaconda to your PATH variable}. Not adding Anaconda to the PATH is the default setting during installation, so you should be fine.

\sphinxAtStartPar
\sphinxincludegraphics{{win-install-destination1}.png}

\sphinxAtStartPar
Anaconda installs some additional tools on your machine, including Anaconda Navigator. This is a tool that conveniently combines several important elements of your Python distribution: environments, packages. For now, we will not discuss environments, but we will do so extensively later in the course.

\begin{sphinxadmonition}{note}{Before you continue}

\sphinxAtStartPar
Before you continue, please make sure that you have successfully installed Anaconda.
\end{sphinxadmonition}


\section{Using the command line}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:using-the-command-line}}
\sphinxAtStartPar
One useful skill to have when working with computers is to be able to effectively use the command line. The command line is a text interface to your computer. You can use it to \sphinxhyphen{} for example \sphinxhyphen{} navigate your computer, create and delete files, and inspect which processes are running. The command line also offers an alternative to the graphics user interface (GUI) that you are used to, and you will find that many software tools can be used either via the command line or via a GUI.

\begin{sphinxadmonition}{note}{Terminal? Shell?}

\sphinxAtStartPar
The words ‘terminal’, ‘command line’, ‘shell’, ‘CLI’, ‘console’, and ‘prompt’ are often used for the same thing: a text\sphinxhyphen{}based interface to your computer.
\end{sphinxadmonition}

\sphinxAtStartPar
To start, open a terminal window. We will here use \sphinxstylestrong{Anaconda Prompt} as terminal. Anaconda Prompt was installed automatically on your computer when you installed Anaconda before. Opening Anaconda Prompt gives you a command line interface (CLI) like below.

\sphinxAtStartPar
\sphinxincludegraphics{{download}.png}

\sphinxAtStartPar
There are many things that you can do with the command line, but one essential skill is to be able to navigate your filesystem. The file system on your computer is organized like a tree, with directories/folders and subdirectories. There is one root directory, which contains either files or folders. Each of those folders can also contain files and folders, etc. The figure below shows an example of such a file system.

\sphinxAtStartPar
\sphinxincludegraphics{{TT_tree_mobile}.jpg}

\sphinxAtStartPar
The table below provides a couple of common commands that you can use to navigate your file system. For example, assuming that the terminal starts in the root directory \sphinxcode{\sphinxupquote{Tom}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Command
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ls}} (short for ‘list’), \sphinxcode{\sphinxupquote{dir}} on Windows
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ls}} / \sphinxcode{\sphinxupquote{dir}}
&
\sphinxAtStartPar
List contents (files and subdirectories) of current directory
\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ls .\textbackslash{}Thesis}} / \sphinxcode{\sphinxupquote{dir .\textbackslash{}Thesis}}
&
\sphinxAtStartPar
List contents in subdirectory \sphinxcode{\sphinxupquote{Thesis}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cd}} (change directory)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cd ..}}
&
\sphinxAtStartPar
Go one level up in directory structure
\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cd .\textbackslash{}Thesis\textbackslash{}}}
&
\sphinxAtStartPar
Go to directory \sphinxcode{\sphinxupquote{Thesis}} which is a subdirectory of the current directory
\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cd \textbackslash{}Tom\textbackslash{}Thesis\textbackslash{}}}
&
\sphinxAtStartPar
Go directly to a directory by using it’s full path on the machine
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Exercise 1.1}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Create a Microsoft Word file called \sphinxcode{\sphinxupquote{AnswersTutorial1.docx}} and save it somewhere on your computer in a folder of your choosing. In this week’s tutorial, you will use this file to store all your answers.

\item {} 
\sphinxAtStartPar
Start a terminal window.

\item {} 
\sphinxAtStartPar
Use the commands above to navigate to the folder where you stored your \sphinxcode{\sphinxupquote{Exercise1.docx}} file. Display the contents of that folder. Make a screenshot of the terminal and paste it to your \sphinxcode{\sphinxupquote{AnswersTutorial1.docx}} file.

\end{enumerate}
\end{sphinxadmonition}


\section{The Python interpreter}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:the-python-interpreter}}
\sphinxAtStartPar
Once you have installed Anaconda, you also have installed the \sphinxstyleemphasis{Python interpreter}. You can use this interpreter as a command line tool that allows you to program in \sphinxstyleemphasis{interactive mode}. To start the Python interpreter, type \sphinxcode{\sphinxupquote{python}} in a terminal and hit Enter. The output should look something like this.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Python} \PYG{l+m+mf}{3.11}\PYG{l+m+mf}{.7} \PYG{o}{|} \PYG{n}{packaged} \PYG{n}{by} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge} \PYG{o}{|} \PYG{p}{(}\PYG{n}{main}\PYG{p}{,} \PYG{n}{Dec} \PYG{l+m+mi}{23} \PYG{l+m+mi}{2023}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{:}\PYG{l+m+mi}{27}\PYG{p}{:}\PYG{l+m+mi}{59}\PYG{p}{)} \PYG{p}{[}\PYG{n}{MSC} \PYG{n}{v}\PYG{l+m+mf}{.1937} \PYG{l+m+mi}{64} \PYG{n}{bit} \PYG{p}{(}\PYG{n}{AMD64}\PYG{p}{)}\PYG{p}{]} \PYG{n}{on} \PYG{n}{win32}
\PYG{n}{Type} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{help}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{copyright}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{credits}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o+ow}{or} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{license}\PYG{l+s+s2}{\PYGZdq{}} \PYG{k}{for} \PYG{n}{more} \PYG{n}{information}\PYG{o}{.}
\PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is some useful information in this output. In particular, on the left you see the Python version that you’re currently using in combination with Anaconda. Like each software tools, there are multiple versions of Python. Versions 3.11 and 3.12 are the newest versions of Python (as of December 2023) and are most likely to be supported in the long run.


\section{Arithmetic operators}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:arithmetic-operators}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{>>>}} in your terminal indicates that you’re in interactive mode and Python is ‘listening’. Anything that you will type here will be parsed, it will be interpreted, and an answer will be returned to you. Let’s give it a try! You can use the interpreter as a calculator and perform some simple arithmetic operations.

\begin{sphinxadmonition}{note}{Exercise 1.2}

\sphinxAtStartPar
Replicate the output below using the Python interpreter.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{4}
\PYG{g+go}{5}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{8}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{6}\PYG{o}{*}\PYG{l+m+mi}{7}
\PYG{g+go}{42}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{8}\PYG{o}{/}\PYG{l+m+mi}{4}
\PYG{g+go}{2.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{5}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}
\PYG{g+go}{11}
\end{sphinxVerbatim}

\sphinxAtStartPar
Remember to press Enter after each line to send your request to the interpreter. Paste the contents of your terminal window into your Word document.
\end{sphinxadmonition}

\sphinxAtStartPar
Two things in the previous outputs are interesting to note. First, Python automatically interprets the minus sign in front of 6 and gives the correct answer. This is similar to what you would write yourself in mathematical notation. In fact, you’ll see that many expressions are quite intuitive. Second, if we divide 8 by 4, we don’t get 2, but we get 2.0. This has to do with the ‘type’ of the number. Like most programming languages, Python differentiates between integer numbers (such as 1, 2, 3, 4, …, 100000, …) and floating point numbers (such as \sphinxhyphen{}45.7, 0.00001, 12.9772). By default, if we divide two numbers using \sphinxcode{\sphinxupquote{/}}, Python returns a floating point number to preserve \sphinxstyleemphasis{precision}.

\sphinxAtStartPar
We can use the interpreter as a calculator. For many standard mathematical operators there is an equivalent in Python. The table below gives an overview of some mathematical operations and how to implement them in Python.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Mathematical notation
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Python
\\
\hline
\sphinxAtStartPar
\(a+b\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a+b}}
\\
\hline
\sphinxAtStartPar
\(a-b\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a\sphinxhyphen{}b}}
\\
\hline
\sphinxAtStartPar
\(ab\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a*b}}
\\
\hline
\sphinxAtStartPar
\(\frac{a}{b}\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a/b}}
\\
\hline
\sphinxAtStartPar
\(\lfloor\frac{a}{b}\rfloor\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a//b}}
\\
\hline
\sphinxAtStartPar
\(a^b\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a**b}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
If you type an expression in the interpreter, it will \sphinxstyleemphasis{return} the answer to you. For example \sphinxcode{\sphinxupquote{5\sphinxhyphen{}\sphinxhyphen{}6}} will result in the output \sphinxcode{\sphinxupquote{11}}. If you want to reuse the output of a previous expression (in this case \sphinxcode{\sphinxupquote{11}}), you can use the \sphinxcode{\sphinxupquote{\_}} symbol. For example, to compute \(4 * 5 + 6\), we can do

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{l+m+mi}{5}
\PYG{g+go}{20}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{\PYGZus{}}\PYG{o}{+}\PYG{l+m+mi}{6}
\PYG{g+go}{26}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course, you can also directly make more complex statements. The use of \sphinxcode{\sphinxupquote{(}} and \sphinxcode{\sphinxupquote{)}} can help you properly structure your inputs. The location of the parentheses affects the output of the interpreter, e.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{l+m+mi}{6}
\PYG{g+go}{26}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{g+go}{44}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Exercise 1.3}

\sphinxAtStartPar
Evaluate the following expressions by hand and use Python to check the answers.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{2/2*3}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{8*63\sphinxhyphen{}9}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{8*(63\sphinxhyphen{}9)}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{7\sphinxhyphen{}5*49}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{6\sphinxhyphen{}2/5+7**2\sphinxhyphen{}1}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{10/25\sphinxhyphen{}3+2*4}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{3**2/4}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{3**2**3}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{(3**2)**3}}

\end{enumerate}

\sphinxAtStartPar
Paste the contents of your terminal window into your Word document.
\end{sphinxadmonition}


\subsection{Modulo operator}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:modulo-operator}}
\sphinxAtStartPar
One operator that you might not yet be familiar with is the modulo operator \sphinxcode{\sphinxupquote{\%}}. The modulo operator returns the remainder or signed remainder of a division, after one number is divided by another. One clear example is time: we can express the time of day using 24 hours, but also using 12 hours. To use only 12 hours, we use a \sphinxcode{\sphinxupquote{\% 12}} to take the modulo of any hour after noon

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{17} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{g+go}{5}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Exercise 1.4}

\sphinxAtStartPar
First, evaluate the following expressions by hand. Then use Python to check your answers. If your answers don’t match, try to figure out why not.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{7 \% 4}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{34 \% 3}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{(6**2) \% 3}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{(7\%3) // 1}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}7 \% \sphinxhyphen{}4}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{2**(5\%3)}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{(7//2)\%2}}

\end{enumerate}

\sphinxAtStartPar
Paste the contents of your terminal window into your Word document.
\end{sphinxadmonition}


\section{Variables}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:variables}}
\sphinxAtStartPar
By now, you can use Python as a basic calculator, but this is not yet real programming. You haven’t really stored values properly yet, only in the last output \sphinxcode{\sphinxupquote{\_}}, so it’s hard to perform more complex computations. One key element of programming is the use of named variables and the ability to store values in those variables.

\begin{sphinxadmonition}{note}{Variables}

\sphinxAtStartPar
A variable is a value that can change, depending on conditions or on information passed to the program.
\end{sphinxadmonition}

\sphinxAtStartPar
Within the Python interpreter, you can define a variable and assign a value to it. To do so, try something like

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{4} 
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You may notice that now, the interpreter does not return an output value. This is so because it has stored the value 4 in variable \sphinxcode{\sphinxupquote{a}} and simply storing a value in a variable does not result in an output. However, we can now simply ask the interpreter for the value of \sphinxcode{\sphinxupquote{a}} and it returns 4.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}
\PYG{g+go}{4}
\end{sphinxVerbatim}

\sphinxAtStartPar
As long as the Python interpreter is running, it will remember what the value of variable \sphinxcode{\sphinxupquote{a}} is. Likewise, we can assign values to other variables.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{7}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then, instead of using \sphinxstyleemphasis{values} to perform computations, we can use \sphinxstyleemphasis{variables} instead. For example, we can perform some basic arithmetic with these variables as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{b}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{c}
\PYG{g+go}{5}
\end{sphinxVerbatim}

\sphinxAtStartPar
Moreover, we can assign the output of such arithmetic to a new variable.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{o}{*}\PYG{n}{b}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{c}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Again, the Python interpreter does not return anything, as we’re just assigning a value to \sphinxcode{\sphinxupquote{d}}. At any moment, you can list all current variables by typing \sphinxcode{\sphinxupquote{vars()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{vars}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}\PYGZsq{}: \PYGZsq{}\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}: None, \PYGZsq{}\PYGZus{}\PYGZus{}package\PYGZus{}\PYGZus{}\PYGZsq{}: None, \PYGZsq{}\PYGZus{}\PYGZus{}loader\PYGZus{}\PYGZus{}\PYGZsq{}: \PYGZlt{}class \PYGZsq{}\PYGZus{}frozen\PYGZus{}importlib.BuiltinImporter\PYGZsq{}\PYGZgt{}, \PYGZsq{}\PYGZus{}\PYGZus{}spec\PYGZus{}\PYGZus{}\PYGZsq{}: None, \PYGZsq{}\PYGZus{}\PYGZus{}annotations\PYGZus{}\PYGZus{}\PYGZsq{}: \PYGZob{}\PYGZcb{}, \PYGZsq{}\PYGZus{}\PYGZus{}builtins\PYGZus{}\PYGZus{}\PYGZsq{}: \PYGZlt{}module \PYGZsq{}builtins\PYGZsq{} (built\PYGZhy{}in)\PYGZgt{}, \PYGZsq{}a\PYGZsq{}: 4, \PYGZsq{}b\PYGZsq{}: 3, \PYGZsq{}c\PYGZsq{}: 7, \PYGZsq{}d\PYGZsq{}: 5\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can always replace the value of a variable, so you can reuse variable names as often as you want.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d} \PYG{o}{=} \PYG{n}{c}\PYG{o}{*}\PYG{o}{*}\PYG{n}{b}\PYG{o}{+}\PYG{n}{a}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d}
\PYG{g+go}{347}
\end{sphinxVerbatim}

\sphinxAtStartPar
Of course, if you assign a new value to a variable, the old value is lost.

\begin{sphinxadmonition}{note}{Exercise 1.5}

\sphinxAtStartPar
Consider the code below. The programmer wanted to swap the values in the variable \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}. However, it does not work in the way the programmer expected.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Explain why the program fails to swap the values.

\item {} 
\sphinxAtStartPar
Fix the program so that the variables are swapped. Verify your program in Python.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{19}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{7}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{b}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Case sensitivity}

\sphinxAtStartPar
Each variable has a name. The \sphinxstyleemphasis{case} of your variable name matters. For example, if you first assign a value to a variable that you call \sphinxcode{\sphinxupquote{a}} and then want to reuse the variable of that variable but (accidentally) type \sphinxcode{\sphinxupquote{A}}, Python will throw an error:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} a=5
\PYGZgt{}\PYGZgt{}\PYGZgt{} b=A*4
Traceback (most recent call last):
  File \PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}, line 1, in \PYGZlt{}module\PYGZgt{}
NameError: name \PYGZsq{}A\PYGZsq{} is not defined
\end{sphinxVerbatim}

\sphinxAtStartPar
This could lead to unexpected behavior, in particular when you actually have two variables defined, one with uppercase and one with lowercase formatting. To prevent such problems, it is good to name your variables according to some standards. We’ll introduce these later.
\end{sphinxadmonition}


\subsection{Assigning values to multiple variables}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:assigning-values-to-multiple-variables}}
\sphinxAtStartPar
For clarity, it is often better to use one line of code to assign a value to one variable, but sometimes you may want to assign values to two variables at the same time. In that case, you can simply separate the variables and values by a comma, as in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is of course important that the number of values matches the numbers of variables. If that is not the case, Python will throw an error.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{ValueError}\PYG{g+gWhitespace}{                                }Traceback (most recent call last)
\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{folders}\PYG{o}{/}\PYG{l+m+mi}{07}\PYG{o}{/}\PYG{n}{x0gf6dj176dfjvrn357t5p6h0000gn}\PYG{o}{/}\PYG{n}{T}\PYG{o}{/}\PYG{n}{ipykernel\PYGZus{}3424}\PYG{o}{/}\PYG{l+m+mf}{1121104675.}\PYG{n}{py} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}

\PYG{n+ne}{ValueError}: not enough values to unpack (expected 3, got 2)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can also assign the \sphinxstyleemphasis{same value} to multiple variables. For example, to create three variables that all have the value \sphinxcode{\sphinxupquote{2}}, you can simply write

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{b} \PYG{o}{=} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Exercise 1.6}

\sphinxAtStartPar
Special numbers like \(\pi\) and Euler’s number \(e\) are not automatically defined in Python. Define these two numbers as variables and use them to compute the volume of a sphere with radius \(e\). Store the result in a new variable called \sphinxcode{\sphinxupquote{v}}.

\sphinxAtStartPar
Paste the contents of your terminal window into your Word document.
\end{sphinxadmonition}


\section{Data types}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:data-types}}
\sphinxAtStartPar
Each variable in Python has a \sphinxstyleemphasis{type} that defines which kind of data it represents. There are four important types in Python that you will also see in almost any programming language:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Integers, or whole numbers, such as 1, 2, 1000, 4000. Integers can be \sphinxstyleemphasis{signed} or \sphinxstyleemphasis{unsigned}. Signed integers can take on negative or positive values, unsigned integers only positive values.

\item {} 
\sphinxAtStartPar
Floating point numbers such as \sphinxhyphen{}1892.3, 0.000045, 1.3040, 9828.322.

\item {} 
\sphinxAtStartPar
Strings, i.e., sequences of characters. For example, ‘Technical medicine’ is a string. The length of strings can vary, e.g., ‘a’ is also a string.

\item {} 
\sphinxAtStartPar
Booleans, which are variables that can take on just two values: \sphinxcode{\sphinxupquote{True}} or \sphinxcode{\sphinxupquote{False}}.

\end{enumerate}

\sphinxAtStartPar
Some programming languages require you to explicitly specify the type of each variable. Instead, Python tries to automatically infer the type of a variable for you and does a good job in most cases. However, it’s always good to be aware of the type of your \sphinxhref{http://variables.To}{variables.To} find out what the type is of a variable, you can use \sphinxcode{\sphinxupquote{type()}}, i.e.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}int\PYGZsq{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{3.1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Technical medicine}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{d} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{g+go}{\PYGZlt{}class \PYGZsq{}bool\PYGZsq{}\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Not all data types are compatible. While you can add integers and floating point numbers, and even booleans and numbers, adding floating point and strings will throw an error.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello world}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{folders}\PYG{o}{/}\PYG{l+m+mi}{07}\PYG{o}{/}\PYG{n}{x0gf6dj176dfjvrn357t5p6h0000gn}\PYG{o}{/}\PYG{n}{T}\PYG{o}{/}\PYG{n}{ipykernel\PYGZus{}3424}\PYG{o}{/}\PYG{l+m+mf}{1642992856.}\PYG{n}{py} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello world}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n+ne}{TypeError}: unsupported operand type(s) for +: \PYGZsq{}int\PYGZsq{} and \PYGZsq{}str\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 1.7}

\sphinxAtStartPar
Define two variables. One should have the value ‘Technical ‘ and the other ‘Medicine’. What is the type of these variables? Try to add these two variables in the Python interpreter. Which result do you get? Can you explain what happened?
\end{sphinxadmonition}


\section{Type casting}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:type-casting}}
\sphinxAtStartPar
In many cases, you can convert one variable type into another type. For example, if we have a variable \sphinxcode{\sphinxupquote{b=3.0}} it has type \sphinxcode{\sphinxupquote{float}}. We can \sphinxstyleemphasis{cast} this variable into a type \sphinxcode{\sphinxupquote{int}} variable by typing \sphinxcode{\sphinxupquote{b = int(b)}}. Similarly, a string can in many \sphinxhyphen{} but not all \sphinxhyphen{} cases be cast into a \sphinxcode{\sphinxupquote{float}} or \sphinxcode{\sphinxupquote{int}} or vice versa.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3.4}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+go}{3.4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{c}\PYG{o}{=}\PYG{l+m+mf}{3.4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Casting an int to a float is the same as a \PYGZsq{}floor\PYGZsq{} operator}
\PYG{g+go}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}3.4\PYGZsq{} }
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that this does not always work. For example, a string which is \sphinxstyleemphasis{not} a number cannot be cast into an \sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{float}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{\PYGZlt{}module\PYGZgt{}}
\PYG{g+gr}{ValueError}: \PYG{n}{invalid literal for int() with base 10: \PYGZsq{}Hello\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+gt}{Traceback (most recent call last):}
  File \PYG{n+nb}{\PYGZdq{}\PYGZlt{}stdin\PYGZgt{}\PYGZdq{}}, line \PYG{l+m}{1}, in \PYG{n}{\PYGZlt{}module\PYGZgt{}}
\PYG{g+gr}{ValueError}: \PYG{n}{could not convert string to float: \PYGZsq{}Hello\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{bool}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}


\section{Comparison operators}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:comparison-operators}}
\sphinxAtStartPar
Some operations by default take inputs of one type and return outputs of another type. A good example of this are comparison operators, which check whether two inputs are the same or different. The comparison operators in Python are as follows.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operator
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
\\
\hline
\sphinxAtStartPar
==
&
\sphinxAtStartPar
Equal
&
\sphinxAtStartPar
x == y
\\
\hline
\sphinxAtStartPar
!=
&
\sphinxAtStartPar
Not equal
&
\sphinxAtStartPar
x != y
\\
\hline
\sphinxAtStartPar
>
&
\sphinxAtStartPar
Greater than
&
\sphinxAtStartPar
x > y
\\
\hline
\sphinxAtStartPar
<
&
\sphinxAtStartPar
Less than
&
\sphinxAtStartPar
x < y
\\
\hline
\sphinxAtStartPar
>=
&
\sphinxAtStartPar
Greater than or equal to
&
\sphinxAtStartPar
x >= y
\\
\hline
\sphinxAtStartPar
<=
&
\sphinxAtStartPar
Less than or equal to
&
\sphinxAtStartPar
x <= y
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The return type of these operators is boolean. For example, evaluating if one integer is smaller or larger than another integer will return a boolean: the statement is either \sphinxcode{\sphinxupquote{True}} or \sphinxcode{\sphinxupquote{False}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{b}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{b}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\sphinxAtStartPar
Special variants of this are the \sphinxcode{\sphinxupquote{not}}, \sphinxcode{\sphinxupquote{or}} and \sphinxcode{\sphinxupquote{and}} operators. These return either \sphinxcode{\sphinxupquote{True}} or \sphinxcode{\sphinxupquote{False}} depending on the input. As you might expect, by writing \sphinxcode{\sphinxupquote{not}} before a statement, we get the opposite value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o+ow}{not} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{or}} and \sphinxcode{\sphinxupquote{and}} we can combine two statements. For example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2} \PYG{o+ow}{and} \PYG{n}{b} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{b} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{4}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\sphinxAtStartPar
And of course, \sphinxcode{\sphinxupquote{and}} and \sphinxcode{\sphinxupquote{or}} can also be combined with \sphinxcode{\sphinxupquote{not}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o+ow}{not} \PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{b} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, parentheses \sphinxcode{\sphinxupquote{()}} matter. For example, consider why following output is correct.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{b} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, you can use \sphinxcode{\sphinxupquote{not}} as a function (more on functions later), where you give the expression as an \sphinxstyleemphasis{argument}. For example, these statements give the same result

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o+ow}{not} \PYG{n}{a} 
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Exercise 1.8}

\sphinxAtStartPar
For each of the following nonsense programs, first write down the expected output yourself. Then verify in the Python interpreter. If your answers don’t match those of Python, consider what might have gone wrong.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{print}} function lets Python print the value between parentheses to the terminal.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{k+kc}{True}
\PYG{n}{b} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{n}{b} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{n}{x} \PYG{o}{=} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a} \PYG{o+ow}{or} \PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x} \PYG{o+ow}{or} \PYG{n}{y}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a} \PYG{o+ow}{or} \PYG{n}{x}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x} \PYG{o+ow}{or} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{n}{b} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{n}{x} \PYG{o}{=} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a} \PYG{o+ow}{and} \PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a} \PYG{o+ow}{and} \PYG{n}{x}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y} \PYG{o+ow}{and} \PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x} \PYG{o+ow}{and} \PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{n}{c} \PYG{o}{=} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{a}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{c} \PYG{o+ow}{and} \PYG{n}{d}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{d}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{d} \PYG{o+ow}{or} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Assignment operators}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:assignment-operators}}
\sphinxAtStartPar
If we have a variable that we want to modify by adding or multiplying with some other number, we can explicitly write the addition, e.g., \sphinxcode{\sphinxupquote{a = a + 5}}, but we can also use the shorthand version \sphinxcode{\sphinxupquote{a += 5}}. This adds \sphinxcode{\sphinxupquote{5}} to the value of \sphinxcode{\sphinxupquote{a}}. Similarly, you can write \sphinxcode{\sphinxupquote{a *= 5}}, etc. There is an assignment operator for each arithmetic operator that you saw before. The assignment operators are as follows.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operator
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Same As
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{+=}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x += 3}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x = x + 3}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}=}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x \sphinxhyphen{}= 3}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x = x \sphinxhyphen{} 3}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{*=}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x *= 3}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x = x * 3}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/=}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x /= 3}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x = x / 3}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\%=}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x \%= 3}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x = x \% 3}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{//=}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x //= 3}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x = x // 3}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{**=}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x **= 3}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x = x ** 3}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Exercise 1.9}

\sphinxAtStartPar
Use assignment operators to change \sphinxhyphen{} in one statement \sphinxhyphen{} the value of variable \sphinxcode{\sphinxupquote{a=4}} into the following. \sphinxstylestrong{You may only use each assignment operator once}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
42

\item {} 
\sphinxAtStartPar
3.0

\item {} 
\sphinxAtStartPar
1024

\item {} 
\sphinxAtStartPar
1

\item {} 
\sphinxAtStartPar
2

\item {} 
\sphinxAtStartPar
4627

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}172

\end{enumerate}

\sphinxAtStartPar
Paste the contents of your terminal window into your Word document.
\end{sphinxadmonition}


\section{Complex numbers}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:complex-numbers}}
\sphinxAtStartPar
A convenient feature of Python is that it comes with built\sphinxhyphen{}in support for complex numbers. You can easily define a complex number as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{n}{j}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can get the real part of the number by typing \sphinxcode{\sphinxupquote{z.real}} and the imaginary part by typing \sphinxcode{\sphinxupquote{z.imag}}.

\begin{sphinxadmonition}{note}{Literals}

\sphinxAtStartPar
As you notice, Python uses the literal \(j\) instead of \(i\) in complex numbers. This is an engineering convention.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 1.10}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Use the Python interpreter to find the type of the variable \sphinxcode{\sphinxupquote{z}}.

\item {} 
\sphinxAtStartPar
Choose two complex numbers. For example \(-3 + 2j\) and \(5-7j\), but you can also choose other numbers. Add, subtract, multiply and divide these numbers in Python.

\end{enumerate}

\sphinxAtStartPar
Paste the contents of your terminal window into your Word document.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Leaving the Python interpreter}

\sphinxAtStartPar
To leave the Python interpreter and go back to your terminal window, type

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{exit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Scripts}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:scripts}}
\sphinxAtStartPar
So far, you have used the Python interpreter to interact with Python. As you can imagine, once you want to write and run a piece of code that contains many steps or lines, it becomes inconvenient to use the interpreter: you would have to write each line of code each time you’re trying to run a program. Instead, you can write Python \sphinxstyleemphasis{scripts} that can be passed to the interpreter, which will run everything line\sphinxhyphen{}by\sphinxhyphen{}line. Python scripts are files that can be \sphinxstyleemphasis{run} and are supposed to do something each time you run them. A Python file ends in \sphinxcode{\sphinxupquote{.py}}, and can be simply a set of statements. For example, the contents of a Python file can be as simple as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{8}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{a}\PYG{o}{*}\PYG{o}{*}\PYG{n}{b}         \PYG{c+c1}{\PYGZsh{} Compute a to the power b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see that these are just four lines of code. In the third line, we have also added a \sphinxstyleemphasis{comment}. This is a piece of human\sphinxhyphen{}readable text that is not part of the code. It will not be run by the Python interpreter. We use the character \sphinxcode{\sphinxupquote{\#}} to indicate that this is a comment. Documenting your code properly with comments is a very valuable way to make sure that you (or someone else) will still understand the code when you look at it later. We’ll go over some common practices for code documentation later.

\sphinxAtStartPar
Running a Python script is straightforward. First, you have to actually create the script. To do this, create a directory/folder on your computer where you intend to store the code of this course. This can be the same directory where you stored the Word file you created earlier. Open Notepad (\sphinxstyleemphasis{Kladblok}) or an equivalent text editor and paste the lines of code above. Then go to \sphinxcode{\sphinxupquote{File}} \sphinxhyphen{}> \sphinxcode{\sphinxupquote{Save as}}, under \sphinxcode{\sphinxupquote{Save as type}} select \sphinxcode{\sphinxupquote{All files}} and save the file as \sphinxcode{\sphinxupquote{test.py}} in the directory you just created. Then, open a command line window and navigate to the directory where you have stored \sphinxcode{\sphinxupquote{test.py}}. To run the script, type \sphinxcode{\sphinxupquote{python test.py}} and press Enter.

\begin{sphinxadmonition}{note}{Exercise 1.11}

\sphinxAtStartPar
What is the output of this script? Add a screenshot to your Word file.
\end{sphinxadmonition}

\sphinxAtStartPar
And that’s it: you’ve written and run your first Python script! Now we can really start programming. There is no limit to how long a script can be and \sphinxhyphen{} as you’ll see \sphinxhyphen{} you can do much more in a script than just processing lines in a fixed order.


\section{Visual Studio Code}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:visual-studio-code}}
\sphinxAtStartPar
For simple programming, Notepad will get you quite far as a script editor. However, most programmers use an ‘integrated development environment’ (IDE) that provides additional tools during programming to increase productivity and help you write clear and reusable code. There are many different IDEs on the market, some focusing on one programming language, others on a range of programming languages. Some are very expensive and intended for professional use, some are free. Some are complex, some are easier to use. In this course, \sphinxstylestrong{we will use Visual Studio Code}, commonly referred to as VS Code. VS Code is free, flexible, and widely considered to be a good entry point for new programmers. In the remainder of the course, we assume that you are using VS Code.

\sphinxAtStartPar
To install VS Code, take the following steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Go to \sphinxhref{https://code.visualstudio.com/download}{the Visual Studio Code website} and download the correct version for your computer. If you’re on a Windows laptop, this is likely going to be the \sphinxstyleemphasis{User Installer} \sphinxcode{\sphinxupquote{x64}} version.

\item {} 
\sphinxAtStartPar
Run the installer to install Visual Studio Code.

\item {} 
\sphinxAtStartPar
Open Visual Studio Code and go to ‘Extensions’ (Ctrl + Shift + X on Windows).

\item {} 
\sphinxAtStartPar
Install the Python extension. \sphinxstylestrong{Warning} There are multiple Python extensions available. You should download the most popular one by Microsoft, which has been downloaded over a 100m times.

\end{enumerate}

\sphinxAtStartPar
If you have properly installed Anaconda as described in the previous chapter, you should now be able to use Python within the VS Code IDE. You can find more information on the combination of Anaconda and VS Code on the \sphinxhref{https://docs.anaconda.com/free/anaconda/ide-tutorials/python-vsc/}{Anaconda website}.

\sphinxAtStartPar
Note that we suggest to use VS Code, but that there are other (free) IDEs that you can also use, like Spyder and PyCharm. The latter is a professional, expensive IDE that provides free licenses to students. Go to \sphinxhref{https://www.jetbrains.com/shop/eform/students}{the JetBrains website} and register as a student. Make sure to use  your University of Twente email account. Once you have received confirmation from JetBrains, download the latest version of PyCharm from \sphinxhref{https://www.jetbrains.com/pycharm/}{the PyCharm website}. Use the license provides to you by JetBrains. In the end, it doesn’t really matter which IDE you use, the Python code that you use is not affected by the IDE. The IDE is just there to help you write code.


\section{Writing scripts in VS Code}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:writing-scripts-in-vs-code}}
\sphinxAtStartPar
With VS Code open, go to the ‘Explorer’ (Ctrl + Shift + E on Windows). Go to \sphinxcode{\sphinxupquote{File}} –> \sphinxcode{\sphinxupquote{Open Folder}} and select the folder you just created and in which you stored \sphinxcode{\sphinxupquote{test.py}}. If all is well, you should see the folder appear in ‘Explorer’, including the \sphinxcode{\sphinxupquote{test.py}} file. You can double click on the \sphinxcode{\sphinxupquote{test.py}} file and it will open in the VS Code editor. You will see that colors are used to highlight individual words and characters in the code. This is called \sphinxstyleemphasis{syntax highlighting} and is a useful tool to make your code readable and easily spot errors. You can change the colors and the general look\sphinxhyphen{}and\sphinxhyphen{}feel of VS Code by picking a different theme. For this, go to \sphinxcode{\sphinxupquote{File}} –> \sphinxcode{\sphinxupquote{Preferences}} –> \sphinxcode{\sphinxupquote{Theme}} –> \sphinxcode{\sphinxupquote{Color Theme}}. Note that this is just a visualization and will not change anything to your code or what your code does. The editor in which you now see your code is basically a text editor with some nice additional functionality to make your life as a programmer easier.


\section{Running scripts in VS Code}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:running-scripts-in-vs-code}}
\sphinxAtStartPar
To run your script in VS Code, first select an interpreter. On Windows, on the bottom right, click on \sphinxcode{\sphinxupquote{Select Interpreter}}. This lets you pick the Python interpreter that you have previously installed with Anaconda. Then, if you select \sphinxcode{\sphinxupquote{Run}} –> \sphinxcode{\sphinxupquote{Run Without Debugging}} (or CTRL + F5) from the menu, VS Code will start a terminal, call the Python interpreter with your script, and output the results in a terminal window.

\begin{sphinxadmonition}{note}{Exercise 1.12}

\sphinxAtStartPar
Write a Python script that prints the first eight numbers in the \sphinxhref{https://en.wikipedia.org/wiki/Fibonacci\_sequence}{Fibonacci sequence}. Use variables in your script. You are only allowed to use a maximum of two digits in your code. Run the script and verify the output.
\end{sphinxadmonition}


\section{Interactive scripts}
\label{\detokenize{notebooks/01_GettingStarted/01_GettingStarted_student:interactive-scripts}}
\sphinxAtStartPar
A Python script will run ‘as is’, i.e., its output is entirely defined by what we put in the script. We can also make the script more interactive by using the \sphinxcode{\sphinxupquote{input()}} function in Python. This asks the user for an input and stores it in a variable.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Please enter your name: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{Please enter your name: Adam}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{name}
\PYG{g+go}{\PYGZsq{}Adam\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can use the \sphinxcode{\sphinxupquote{input()}} function in a script to let the script compute something else depending on the users input. Keep in mind that \sphinxcode{\sphinxupquote{input()}} always returns a string. Hence, if you want to ask the user for an \sphinxcode{\sphinxupquote{int}} or a \sphinxcode{\sphinxupquote{float}} instead, you will have to cast your variables.

\begin{sphinxadmonition}{note}{Exercise 1.13}

\sphinxAtStartPar
Write Python scripts for \sphinxstylestrong{at least two of} the following tasks. Use the \sphinxcode{\sphinxupquote{input()}} and \sphinxcode{\sphinxupquote{print()}} functions.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A script that asks the user for the radius of a sphere and prints the volume of the sphere.

\item {} 
\sphinxAtStartPar
A script that asks the user for two numbers and prints whether the first number is larger than the second number.

\item {} 
\sphinxAtStartPar
A script that asks the user for numbers \(a\), \(b\) and \(c\) and prints whether \(a\mod b > c\).

\item {} 
\sphinxAtStartPar
A script that asks the user for the height, width and depth of a box and returns it’s volume and surface area.

\end{enumerate}
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Containers}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:containers}}\label{\detokenize{notebooks/02_Containers/02_Containers_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
be able to work with different kinds of containers in Python

\item {} 
\sphinxAtStartPar
understand differences between \sphinxcode{\sphinxupquote{tuple}}, \sphinxcode{\sphinxupquote{list}}, \sphinxcode{\sphinxupquote{set}}, and \sphinxcode{\sphinxupquote{dict}} containers

\item {} 
\sphinxAtStartPar
index and slice tuples and lists

\item {} 
\sphinxAtStartPar
know how to format strings

\end{itemize}
\end{sphinxadmonition}


\section{Tuples, lists, sets, and dictionaries}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:tuples-lists-sets-and-dictionaries}}
\sphinxAtStartPar
In the previous chapter, we have introduced four basic Python data types: integers, floating point numbers, strings, and booleans. Variables of this type allow the user to store one value, e.g.,

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{course\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Introduction to programming}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{year} \PYG{o}{=} \PYG{l+m+mi}{2024}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
In many practical scenarios, you might want to store multiple values in one variable. For example, when creating an overview of all students in one variable, or when you are working with matrices in mathematics. For this, Python has four very useful data types: tuples, lists, sets and dictionaries. These are called \sphinxstyleemphasis{containers}, which can be used to store multiple values or variables. There are similarities, but also important differences between these four data types. In this chapter we’ll discuss these.


\section{Tuple}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:tuple}}
\sphinxAtStartPar
A tuple is a container for multiple items that is \sphinxstyleemphasis{immutable}. Immutability means that once a tuple has been created, we cannot change its contents. You recognize a tuple in Python by the use of parentheses \sphinxcode{\sphinxupquote{()}}. For example, we can define a tuple with three numbers as follows.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{3}}, \sphinxcode{\sphinxupquote{4}} and \sphinxcode{\sphinxupquote{5}} now together form a tuple, and the variable \sphinxcode{\sphinxupquote{digits}} contains this tuple and thus these items. The items in a tuple can have any type. For example, we can also create a tuple of strings

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{student\PYGZus{}names} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Alice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bob}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Claire}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
or a tuple of booleans

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{passed\PYGZus{}course} \PYG{o}{=} \PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The last example shows that a tuple can contain the same value multiple times: it’s contents are \sphinxstyleemphasis{ordered} and they will stay in their order (even if they are not ascending or descending, or alphabetically ordered).

\sphinxAtStartPar
We can access the value of an individual item in the tuple using \sphinxcode{\sphinxupquote{{[}{]}}}. This is called \sphinxstyleemphasis{indexing}. For example, to get the value of the \sphinxstylestrong{first} element in the tuple \sphinxcode{\sphinxupquote{student\_names}}, we use the \sphinxstyleemphasis{index} of that element in \sphinxcode{\sphinxupquote{student\_names}} and write

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{student\PYGZus{}names}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Alice
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Note that to get the \sphinxstylestrong{first} element, we use index 0. In most programming languages, we start counting at 0, and not at 1.
\end{sphinxadmonition}

\sphinxAtStartPar
If you have a tuple, you can always use indexing to get the value of an individual item. This way, you can also get the value of the second and third item in \sphinxcode{\sphinxupquote{student\_names}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{student\PYGZus{}names}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{student\PYGZus{}names}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Bob
Claire
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that \sphinxstyleemphasis{getting} the value of an item in the tuple does not change anything to the tuple itself. The tuple is still the same if we get the value of an item.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{student\PYGZus{}names}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZsq{}Alice\PYGZsq{}, \PYGZsq{}Bob\PYGZsq{}, \PYGZsq{}Claire\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Because a tuple is \sphinxstylestrong{immutable}, we cannot change the values of individual items, or \sphinxstyleemphasis{assign} a value to one of the elements. Let’s give that a try below. In this line of code, we try to change the name of a student in the tuple.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{student\PYGZus{}names}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bert}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{folders}\PYG{o}{/}\PYG{l+m+mi}{07}\PYG{o}{/}\PYG{n}{x0gf6dj176dfjvrn357t5p6h0000gn}\PYG{o}{/}\PYG{n}{T}\PYG{o}{/}\PYG{n}{ipykernel\PYGZus{}36825}\PYG{o}{/}\PYG{l+m+mf}{34016667.}\PYG{n}{py} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{student\PYGZus{}names}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bert}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n+ne}{TypeError}: \PYGZsq{}tuple\PYGZsq{} object does not support item assignment
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Indeed, we get an error. Take a close look at this error, it tells you exactly what the problem is: tuples do not allow item assignment.

\sphinxAtStartPar
Instead of indexing from the \sphinxstyleemphasis{start} of a tuple, you can also index by counting back from the last element by using negative integer numbers, where index \sphinxhyphen{}1 refers to the last item, \sphinxhyphen{}2 to the second\sphinxhyphen{}to\sphinxhyphen{}last item, etc.

\begin{sphinxadmonition}{note}{Exercise 2.1}

\sphinxAtStartPar
Why do \sphinxcode{\sphinxupquote{student\_names{[}0{]}}} and \sphinxcode{\sphinxupquote{student\_names{[}\sphinxhyphen{}3{]}}} refer to the same item?
\end{sphinxadmonition}

\sphinxAtStartPar
In addition to selecting a \sphinxstyleemphasis{single} item using indexing, we can also select \sphinxstyleemphasis{multiple} items at once. This is called \sphinxstyleemphasis{slicing}. Slicing works with start, end, and step indices. These are used in the following syntax

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sub\PYGZus{}items} \PYG{o}{=} \PYG{n}{some\PYGZus{}tuple}\PYG{p}{[}\PYG{n}{start}\PYG{p}{:}\PYG{n}{end}\PYG{p}{:}\PYG{n}{step}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the example below, we select all items starting at index 3 and until (but not including) index 5. Note that in this example, the step is not provided. In this case, Python assumes that you want to use a step size of 1.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{food} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spam}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{egg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bacon}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tomato}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ham}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lobster}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{food}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZsq{}tomato\PYGZsq{}, \PYGZsq{}ham\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If you only provide an end index, Python assumes that you mean to slice up to that index. Conversely, if you only provide a start index, Python assumes that you intend to slice the full tuple from that index on. This is shown in the following two examples.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{food}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{food}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZsq{}spam\PYGZsq{}, \PYGZsq{}egg\PYGZsq{}, \PYGZsq{}bacon\PYGZsq{}, \PYGZsq{}tomato\PYGZsq{})
(\PYGZsq{}bacon\PYGZsq{}, \PYGZsq{}tomato\PYGZsq{}, \PYGZsq{}ham\PYGZsq{}, \PYGZsq{}lobster\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If the start and end index are both undefined, we are simply selecting all items in the items

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{food}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZsq{}spam\PYGZsq{}, \PYGZsq{}egg\PYGZsq{}, \PYGZsq{}bacon\PYGZsq{}, \PYGZsq{}tomato\PYGZsq{}, \PYGZsq{}ham\PYGZsq{}, \PYGZsq{}lobster\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{step}} lets us select only a subset of items. For example, to select every second item in the tuple between indices 2 and 6, the following code can be used, in which the step is 2.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{food}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZsq{}bacon\PYGZsq{}, \PYGZsq{}ham\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Steps can also be negative, in which case the tuple is traversed in the \sphinxstyleemphasis{reverse} direction. Here, it is important that you pick your start and end indices correctly. For example, the following code will not return anything.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{food}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
()
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 2.2}

\sphinxAtStartPar
Why does this code not print anything?
\end{sphinxadmonition}

\sphinxAtStartPar
Instead, to traverse the tuple in reverse, the start index should be higher than the end index:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{food}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZsq{}lobster\PYGZsq{}, \PYGZsq{}ham\PYGZsq{}, \PYGZsq{}tomato\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This also provides an easy way to flip the items in a tuple. Remember that by not providing a start and end, we select the whole tuple. By then providing a negative step size, we ask Python to provide the full tuple in reverse.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{food}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZsq{}lobster\PYGZsq{}, \PYGZsq{}ham\PYGZsq{}, \PYGZsq{}tomato\PYGZsq{}, \PYGZsq{}bacon\PYGZsq{}, \PYGZsq{}egg\PYGZsq{}, \PYGZsq{}spam\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
It’s often useful to know the length of a tuple, or the number of items in the tuple. For this, we can use the \sphinxcode{\sphinxupquote{len}} function.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{food}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Items in a tuple can be variables, and tuples can contain other tuples. By nesting your indices, you can access the individual items in the \sphinxstyleemphasis{nested} tuple. Similarly, you can slice items in your tuple.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vegetables} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tomato}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eggplant}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{groceries} \PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cheese}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bread}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vegetables}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{milk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{groceries}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{groceries}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZsq{}cheese\PYGZsq{}, \PYGZsq{}bread\PYGZsq{}, (\PYGZsq{}tomato\PYGZsq{}, \PYGZsq{}eggplant\PYGZsq{}), \PYGZsq{}milk\PYGZsq{})
eggplant
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{List}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:list}}
\sphinxAtStartPar
Lists are the most commonly used container objects in Python. Like a tuple, a list can contain multiple items. Also similarly to a tuple, these items are ordered. Different than in a tuple, a list is \sphinxstyleemphasis{mutable}: we can add, change, and remove items. A list is defined using square brackets \sphinxcode{\sphinxupquote{{[}{]}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3, 5, 4]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To illustrate what we mean with \sphinxstyleemphasis{mutable}, let’s use indexing to assign a new value to the second element

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{6}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3, 6, 4]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note how \sphinxhyphen{} in contrast to the tuple \sphinxhyphen{} we don’t get an error in this case!

\sphinxAtStartPar
We can not only change values of items in the list, but also add items or remove items. To add a single item to a list, you can use the \sphinxcode{\sphinxupquote{append}} function, as in the following example

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3, 6, 4, 6]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If you want to add multiple items, you can use the \sphinxcode{\sphinxupquote{extend}} function as follows

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3, 6, 4, 6, 7, 8]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Equivalently, using the assignment operator \sphinxcode{\sphinxupquote{+=}} that you learned last week, you can achieve the same result

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[3, 6, 4, 6, 7, 8, 9, 10]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that addition for two lists is the same as concatenation.

\sphinxAtStartPar
You can also make a list ‘from scratch’ by just starting with an empty list and adding items as you go, like this:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{student\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{student\PYGZus{}names}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Alice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{student\PYGZus{}names}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bob}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{student\PYGZus{}names} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Clark}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Denise}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{student\PYGZus{}names}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}Alice\PYGZsq{}, \PYGZsq{}Bob\PYGZsq{}, \PYGZsq{}Clark\PYGZsq{}, \PYGZsq{}Denise\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Indexing and slicing }

\sphinxAtStartPar
Indexing and slicing work the same way for lists and tuples. The length of a list can also be determined using \sphinxcode{\sphinxupquote{len}}. E.g.,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cheeses} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gouda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{brie}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mozarella}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{list\PYGZus{}length} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{cheeses}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
There are two ways to remove items from a list. First, the \sphinxcode{\sphinxupquote{pop}} method removes an item from a list at a given \sphinxstyleemphasis{index} and returns its value. Second, the \sphinxcode{\sphinxupquote{remove}} method removes an item based on its \sphinxstyleemphasis{value}. The code below demonstrates this.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fruits} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{apple}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{banana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{popped} \PYG{o}{=} \PYG{n}{fruits}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fruits}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{popped}\PYG{p}{)}
\PYG{n}{fruits}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cherry}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fruits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}apple\PYGZsq{}, \PYGZsq{}cherry\PYGZsq{}]
banana
[\PYGZsq{}apple\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that lists allow multiple items to have the same value and \sphinxcode{\sphinxupquote{remove}} only removes the first matching occurence.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{motto} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hodor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hodor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hodor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{motto}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hodor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{motto}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}hodor\PYGZsq{}, \PYGZsq{}hodor\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 2.3}

\sphinxAtStartPar
Write scripts for the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Use indexing and assignment to sort the items in the list \sphinxcode{\sphinxupquote{scrambled\_numbers = {[}7, 2, 5, 1{]}}} in ascending order.

\item {} 
\sphinxAtStartPar
Split the list \sphinxcode{\sphinxupquote{numbers = {[}1, 2, 3, 4, 5, 6, 7, 8, 9, 10{]}}} into a list of even numbers and a list of uneven numbers using slicing.

\item {} 
\sphinxAtStartPar
Given list \sphinxcode{\sphinxupquote{l = {[}10, 20, 30, 40, 'a', 'dog', 3.4, True{]}}}, make two new lists: one containing every second item counting from the back, and one containing every third item starting from the front.

\item {} 
\sphinxAtStartPar
Given tuple \sphinxcode{\sphinxupquote{t = ("Orange", {[}10, 20, 30{]}, (5, 15, 25))}}, write code to extract the value \sphinxcode{\sphinxupquote{15}} from \sphinxcode{\sphinxupquote{t}}.

\end{enumerate}
\end{sphinxadmonition}


\section{Set}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:set}}
\sphinxAtStartPar
A set is a container that is unordered and does not allow duplicate values. Sets cannot contain multiple items with the same value. Sets are defined using curly brackets \sphinxcode{\sphinxupquote{\{\}}}. In the example below, you can note two things
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Although we assign two \sphinxcode{\sphinxupquote{5}}s to the set, the set only contains one \sphinxcode{\sphinxupquote{5}}. The reason for this is that a set does not allow duplicate values.

\item {} 
\sphinxAtStartPar
Although the \sphinxcode{\sphinxupquote{4}} comes after the \sphinxcode{\sphinxupquote{5}} in our assignment, the order is swapped to be increasing in the eventual set. This is the case because a set is not ordered: elements are always sorted in ascending order for printing.

\end{enumerate}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}3, 4, 5\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You will find that sets can be very useful when you want to perform common mathematical operations like unions and intersections. Sets have some built\sphinxhyphen{}in \sphinxstyleemphasis{functions} that allow you do this. For example, if we have two groups of people, we can use sets for boolean operators.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{team\PYGZus{}a} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Adam}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bob}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Claire}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dean}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{team\PYGZus{}b} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bob}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dean}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Edward}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fran}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{team\PYGZus{}a}\PYG{o}{.}\PYG{n}{intersection}\PYG{p}{(}\PYG{n}{team\PYGZus{}b}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Who is in both groups (intersection)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{team\PYGZus{}a}\PYG{o}{.}\PYG{n}{union}\PYG{p}{(}\PYG{n}{team\PYGZus{}b}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} All people (union)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{team\PYGZus{}a}\PYG{o}{.}\PYG{n}{difference}\PYG{p}{(}\PYG{n}{team\PYGZus{}b}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Everyone who is uniquely in group a}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}Dean\PYGZsq{}, \PYGZsq{}Bob\PYGZsq{}\PYGZcb{}
\PYGZob{}\PYGZsq{}Dean\PYGZsq{}, \PYGZsq{}Fran\PYGZsq{}, \PYGZsq{}Bob\PYGZsq{}, \PYGZsq{}Claire\PYGZsq{}, \PYGZsq{}Adam\PYGZsq{}, \PYGZsq{}Edward\PYGZsq{}\PYGZcb{}
\PYGZob{}\PYGZsq{}Adam\PYGZsq{}, \PYGZsq{}Claire\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Just like in tuples, you cannot assign values to indices in sets. However, you can add and remove elements from sets using the \sphinxcode{\sphinxupquote{add}} and \sphinxcode{\sphinxupquote{remove}} functions, as follows.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{team\PYGZus{}a}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Edward}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{team\PYGZus{}a}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}Dean\PYGZsq{}, \PYGZsq{}Bob\PYGZsq{}, \PYGZsq{}Claire\PYGZsq{}, \PYGZsq{}Adam\PYGZsq{}, \PYGZsq{}Edward\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Dictionary}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:dictionary}}
\sphinxAtStartPar
A dictionary is a collection that contains items which are pairs of keys and values. As with lists, tuples and sets, a dictionary can contain items with different data types. Keys do not necessarily have a specific type, and neither do values. Dictionaries ar defined using curly brackets \sphinxcode{\sphinxupquote{\{\}}} and keys and values are separated using a colon \sphinxcode{\sphinxupquote{:}}. Each item in a dictionary should have a key and a value.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{car} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{brand}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ford}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mustang}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{year}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1964}\PYG{p}{\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{car}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}brand\PYGZsq{}: \PYGZsq{}Ford\PYGZsq{}, \PYGZsq{}model\PYGZsq{}: \PYGZsq{}Mustang\PYGZsq{}, \PYGZsq{}year\PYGZsq{}: 1964\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Single or double quotes}

\sphinxAtStartPar
Some programming languages distinguish between using ‘single quotes’ and “double quotes”, but Python does not. You’re free to choose what you prefer. As you can see above, even if you use double quotes, Python will turn these into single quotes.
\end{sphinxadmonition}

\sphinxAtStartPar
Dictionaries are very useful in many applications that you will see during this course. Note that we cannot use indexing and slicing in dictionaries, but we can get values in dictionaries by using keys. For example, if the dictionary above defines a car, we can use \sphinxcode{\sphinxupquote{car{[}'brand'{]}}} to get the brand of this car.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{car}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{brand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Ford
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If you want to add something to an existing dictionary, you can simply assign a new key and value pair as follows

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{car}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{color}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Blue}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{car}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}brand\PYGZsq{}: \PYGZsq{}Ford\PYGZsq{}, \PYGZsq{}model\PYGZsq{}: \PYGZsq{}Mustang\PYGZsq{}, \PYGZsq{}year\PYGZsq{}: 1964, \PYGZsq{}color\PYGZsq{}: \PYGZsq{}Blue\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To remove an key\sphinxhyphen{}value pair from a dictionary, use \sphinxcode{\sphinxupquote{del}} as follows.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{del} \PYG{n}{car}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{car}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}brand\PYGZsq{}: \PYGZsq{}Ford\PYGZsq{}, \PYGZsq{}year\PYGZsq{}: 1964, \PYGZsq{}color\PYGZsq{}: \PYGZsq{}Blue\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that dictionary keys and values can have any type. They don’t have to be strings or integers. This makes dictionaries very flexible and useful in practice. However, there are some restrictions that you should keep in mind:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A key can only appears in a dictionary once, duplicate keys are not allowed.

\item {} 
\sphinxAtStartPar
If you assign a new value to a key, it overwrites the old value.

\end{enumerate}


\section{Converting between collections}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:converting-between-collections}}
\sphinxAtStartPar
If your data is organized in a set, you can turn it into a list or vice versa. Remember how in the previous chapter we could \sphinxstyleemphasis{cast} an integer as a float and vice versa? We can do the same with containers by changing their type. However, keep in mind the characteristics of these data types. For example, if you have a list with \sphinxstyleemphasis{duplicate} values and you turn that into a set, you’ll lose the duplicates. This \sphinxstyleemphasis{can} be convenient, for example if you want to automatically select all unique values in a list. In the code below, notice how the set contains all unique elements in the list, ordered in ascending order, while the tuple maintains the original order and preserves duplicates.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{digits\PYGZus{}list}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Cast digits\PYGZus{}list to a set }
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n}{digits\PYGZus{}list}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Cast digits\PYGZus{}list to a tuple}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}1, 2, 3, 4, 5\PYGZcb{}
(1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 4, 5)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Dictionaries cannot be directly transformed into lists, sets, or tuples, as only the keys will be preserved. However, you can get a list of either the keys or values in a dictionary using the \sphinxcode{\sphinxupquote{keys()}} and \sphinxcode{\sphinxupquote{values()}} methods

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{car} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{brand}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ford}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mustang}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{year}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1964}\PYG{p}{\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{car}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{car}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}brand\PYGZsq{}, \PYGZsq{}model\PYGZsq{}, \PYGZsq{}year\PYGZsq{}]
[\PYGZsq{}Ford\PYGZsq{}, \PYGZsq{}Mustang\PYGZsq{}, 1964]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To create a new dictionary from two lists (one containing keys, one values), use the \sphinxcode{\sphinxupquote{zip}} function. This function takes two lists and, like a zipper, iterates over pairs of items in both lists. Each pair is combined in a tuple, and a new list is made using all these tuples. Using the \sphinxcode{\sphinxupquote{dict}} function, this list can be turned into a dictionary. The following code illustrates this.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{keys} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{brand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{model}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{year}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{values} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ford}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mustang}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1964}\PYG{p}{]}
\PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{keys}\PYG{p}{,} \PYG{n}{values}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}brand\PYGZsq{}: \PYGZsq{}Ford\PYGZsq{}, \PYGZsq{}model\PYGZsq{}: \PYGZsq{}Mustang\PYGZsq{}, \PYGZsq{}year\PYGZsq{}: 1964\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 2.4}

\sphinxAtStartPar
Write scripts for the following tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Given the below dictionary, write a line of code that outputs Mike’s grade for history.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{class}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{student}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mike}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
            \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{grades}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{physics}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{70}\PYG{p}{,}
                \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{history}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{80}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Given the below dictionary, raise the salary of Brad to 6800.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jhon}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{7500}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Emma}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{8000}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{emp3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Brad}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{500}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Define a dictionary called \sphinxcode{\sphinxupquote{student}} that contains your own name, hair color, and age.

\item {} 
\sphinxAtStartPar
Create a list containing yourself and two additional students as dictionaries.

\end{enumerate}
\end{sphinxadmonition}


\section{The \sphinxstyleliteralintitle{\sphinxupquote{in}} operator}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:the-in-operator}}
\sphinxAtStartPar
For tuples, lists, sets, and dictionaries, Python provides the \sphinxcode{\sphinxupquote{in}} operator, which checks whether a value is present in the collection. If so, it returns \sphinxcode{\sphinxupquote{True}}, if not it returns \sphinxcode{\sphinxupquote{False}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{digits} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{digits}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{digits}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n}{digits}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{digits\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{digits\PYGZus{}dict}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
True
True
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This operator can also be easily combined with \sphinxcode{\sphinxupquote{not}} to ask for the opposite response. Consider the following example.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{car} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{brand}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ford}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mustang}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{year}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1964}\PYG{p}{\PYGZcb{}}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{brand}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{car}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In addition to tuples, lists, sets and dictionaries, the \sphinxcode{\sphinxupquote{in}} operator also works for strings. For a string, the \sphinxcode{\sphinxupquote{in}} operator checks whether a character or substring is part of that string. For example:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{supercalifragilisticexpialidocious}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{i}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{my\PYGZus{}string}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{califragi}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{my\PYGZus{}string}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{my\PYGZus{}string}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
True
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Containers: summary}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:containers-summary}}
\sphinxAtStartPar
There are some important differences between tuples, lists, sets and dictonaries. The following table \sphinxhref{https://www.geeksforgeeks.org/differences-and-applications-of-list-tuple-set-and-dictionary-in-python/}{(source)} nicely summarizes the differences between tuples, lists, sets and dictionaries. We’ll elaborate below.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Tuple
&\sphinxstyletheadfamily 
\sphinxAtStartPar
List
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Set
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Dictionary
\\
\hline
\sphinxAtStartPar
A tuple is a non\sphinxhyphen{}homogeneous data structure that stores elements in columns of a single row or multiple rows.
&
\sphinxAtStartPar
A list is a non\sphinxhyphen{}homogeneous data structure that stores the elements in columns of a single row or multiple rows.
&
\sphinxAtStartPar
The set data structure is also a non\sphinxhyphen{}homogeneous data structure but stores the elements in a single row.
&
\sphinxAtStartPar
A dictionary is also a non\sphinxhyphen{}homogeneous data structure that stores key\sphinxhyphen{}value pairs.
\\
\hline
\sphinxAtStartPar
Tuple can be represented by  ( )
&
\sphinxAtStartPar
The list can be represented by {[} {]}
&
\sphinxAtStartPar
The set can be represented by \{ \}
&
\sphinxAtStartPar
The dictionary can be represented by \{ \}
\\
\hline
\sphinxAtStartPar
Tuple allows duplicate elements
&
\sphinxAtStartPar
The list allows duplicate elements
&
\sphinxAtStartPar
The Set will not allow duplicate elements
&
\sphinxAtStartPar
The dictionary doesn’t allow duplicate keys.
\\
\hline
\sphinxAtStartPar
Tuple can use nested among all
&
\sphinxAtStartPar
The list can use nested among all
&
\sphinxAtStartPar
The set can use nested among all
&
\sphinxAtStartPar
The dictionary can use nested among all
\\
\hline
\sphinxAtStartPar
Example: \sphinxcode{\sphinxupquote{(1, 2, 3, 4, 5)}}
&
\sphinxAtStartPar
Example: \sphinxcode{\sphinxupquote{{[}1, 2, 3, 4, 5{]}}}
&
\sphinxAtStartPar
Example: \sphinxcode{\sphinxupquote{\{1, 2, 3, 4, 5\}}}
&
\sphinxAtStartPar
Example: \sphinxcode{\sphinxupquote{\{1: “a”, 2: “b”, 3: “c”, 4: “d”, 5: “e”\}}}
\\
\hline
\sphinxAtStartPar
Tuple can be created using the \sphinxcode{\sphinxupquote{tuple()}} function.
&
\sphinxAtStartPar
A list can be created using the \sphinxcode{\sphinxupquote{list()}} function
&
\sphinxAtStartPar
A set can be created using the \sphinxcode{\sphinxupquote{set()}} function
&
\sphinxAtStartPar
A dictionary can be created using the \sphinxcode{\sphinxupquote{dict()}} function.
\\
\hline
\sphinxAtStartPar
A tuple is immutable i.e we can not make any changes in the tuple.
&
\sphinxAtStartPar
A list is mutable i.e we can make any changes in the list.
&
\sphinxAtStartPar
A set is mutable i.e we can make any changes in the set, but elements are not duplicated.
&
\sphinxAtStartPar
A dictionary is mutable, but keys are not duplicated.
\\
\hline
\sphinxAtStartPar
Tuple is ordered
&
\sphinxAtStartPar
List is ordered
&
\sphinxAtStartPar
Set is unordered
&
\sphinxAtStartPar
Dictionary is ordered (Python 3.7 and above)
\\
\hline
\sphinxAtStartPar
Creating an empty Tuple \sphinxcode{\sphinxupquote{t=()}}
&
\sphinxAtStartPar
Creating an empty list \sphinxcode{\sphinxupquote{l={[}{]}}}
&
\sphinxAtStartPar
Creating a set \sphinxcode{\sphinxupquote{a=set()}} \sphinxcode{\sphinxupquote{b=set(a)}}
&
\sphinxAtStartPar
Creating an empty dictionary \sphinxcode{\sphinxupquote{d=\{\}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{String formatting}
\label{\detokenize{notebooks/02_Containers/02_Containers_student:string-formatting}}
\sphinxAtStartPar
Oftentimes when we want to print something in a Python script, we want to include variable values in the print statement. Python formatting uses the \sphinxcode{\sphinxupquote{format}} function, which is a very powerful way to make your print statements more dynamic. Consider the following example.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{45}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{76}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The sum of }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ and }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ is }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
The sum of 45 and 76 is 121
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Changing the values of the variables \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}} also changes the output of the print statement. To make sure that the right values end up in the right place, you can also name the formatted parts of your string, as follows

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{45}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{76}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The sum of }\PYG{l+s+si}{\PYGZob{}number\PYGZus{}a\PYGZcb{}}\PYG{l+s+s1}{ and }\PYG{l+s+si}{\PYGZob{}number\PYGZus{}b\PYGZcb{}}\PYG{l+s+s1}{ is }\PYG{l+s+si}{\PYGZob{}sum\PYGZus{}numbers\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{number\PYGZus{}a}\PYG{o}{=}\PYG{n}{a}\PYG{p}{,} \PYG{n}{number\PYGZus{}b}\PYG{o}{=}\PYG{n}{b}\PYG{p}{,} \PYG{n}{sum\PYGZus{}numbers}\PYG{o}{=}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
The sum of 45 and 76 is 121
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If you have a floating point number with many decimals, you can also control the number of decimals that actually get printed, as follows.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{9}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Prints the \PYGZsq{}raw\PYGZsq{} value of a with many decimals}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Only prints two decimals}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}number:.2f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{number}\PYG{o}{=}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Same as in previous line, but now with named argument}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.1111111111111111
0.11
0.11
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 2.5}

\sphinxAtStartPar
The table below shows the average temperature in Enschede per month.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Average
&\sphinxstyletheadfamily 
\sphinxAtStartPar
January
&\sphinxstyletheadfamily 
\sphinxAtStartPar
February
&\sphinxstyletheadfamily 
\sphinxAtStartPar
March
&\sphinxstyletheadfamily 
\sphinxAtStartPar
April
&\sphinxstyletheadfamily 
\sphinxAtStartPar
May
&\sphinxstyletheadfamily 
\sphinxAtStartPar
June
&\sphinxstyletheadfamily 
\sphinxAtStartPar
July
&\sphinxstyletheadfamily 
\sphinxAtStartPar
August
&\sphinxstyletheadfamily 
\sphinxAtStartPar
September
&\sphinxstyletheadfamily 
\sphinxAtStartPar
October
&\sphinxstyletheadfamily 
\sphinxAtStartPar
November
&\sphinxstyletheadfamily 
\sphinxAtStartPar
December
\\
\hline
\sphinxAtStartPar
Temp.
&
\sphinxAtStartPar
2°C
&
\sphinxAtStartPar
3°C
&
\sphinxAtStartPar
6°C
&
\sphinxAtStartPar
9°C
&
\sphinxAtStartPar
13°C
&
\sphinxAtStartPar
16°C
&
\sphinxAtStartPar
18°C
&
\sphinxAtStartPar
17°C
&
\sphinxAtStartPar
14°C
&
\sphinxAtStartPar
10°C
&
\sphinxAtStartPar
6°C
&
\sphinxAtStartPar
3°C
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Use this information for the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Put this information in a dictionary, use strings as keys and integers as values.

\item {} 
\sphinxAtStartPar
Then, use the dictionary and print the following statements. Use \sphinxcode{\sphinxupquote{format}} for the italic parts in
\begin{itemize}
\item {} 
\sphinxAtStartPar
‘The average temperature in \sphinxstyleemphasis{March} is \sphinxstyleemphasis{6}°C’

\item {} 
\sphinxAtStartPar
‘The average temperature in \sphinxstyleemphasis{August} is \sphinxstyleemphasis{17}°C’

\item {} 
\sphinxAtStartPar
‘The average temperature in \sphinxstyleemphasis{July} is \sphinxstyleemphasis{15}°C higher than in \sphinxstyleemphasis{February}’

\end{itemize}

\end{itemize}
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Control structures}
\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student:control-structures}}\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
use \sphinxcode{\sphinxupquote{if}}, \sphinxcode{\sphinxupquote{elif}}, and \sphinxcode{\sphinxupquote{else}}

\item {} 
\sphinxAtStartPar
write \sphinxcode{\sphinxupquote{while}} loops

\item {} 
\sphinxAtStartPar
write \sphinxcode{\sphinxupquote{for}} loops

\end{itemize}
\end{sphinxadmonition}


\section{Conditional statements with \sphinxstyleliteralintitle{\sphinxupquote{if}}}
\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student:conditional-statements-with-if}}
\sphinxAtStartPar
Now that you are able to write and run scripts in VS Code, it is time to do some more interesting programming. So far, your scripts have been quite predictable. They are a series of statements that are executed from top to bottom, i.e., sequential execution. One nice feature of almost all programming languages is that they allow the use of \sphinxstyleemphasis{control structures} that direct the execution of your program. One of the most commonly used control structures is the conditional statement \sphinxcode{\sphinxupquote{if}}. An \sphinxcode{\sphinxupquote{if}} statement looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{o}{\PYGZlt{}}\PYG{n}{expr}\PYG{o}{\PYGZgt{}}\PYG{p}{:}
    \PYG{o}{\PYGZlt{}}\PYG{n}{statement}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, \sphinxcode{\sphinxupquote{<expr>}} is a \sphinxstyleemphasis{boolean} expression, i.e., something that takes on the value \sphinxcode{\sphinxupquote{True}} or \sphinxcode{\sphinxupquote{False}}. The \sphinxcode{\sphinxupquote{<statement>}} is a valid Python statement, something that will be executed if \sphinxcode{\sphinxupquote{<expr>}} evaluates to \sphinxcode{\sphinxupquote{True}}. The colon \sphinxcode{\sphinxupquote{:}} is part of the Python syntax and should always be placed after the boolean expression. Further, note that there is some whitespace in front of the \sphinxcode{\sphinxupquote{<statement>}}. This is called \sphinxstyleemphasis{indentation} and is also part of the Python syntax. Python uses four spaces as indentation. You usually don’t have to care of this yourself: the interpreter and any IDE that knows that you’re programming in Python will help you automatically use that indentation when necessary.

\sphinxAtStartPar
To get a better feeling about the behavior of the \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}statement, take a good look at the following code examples. Note that the interpreter only prints \sphinxcode{\sphinxupquote{yes}} if the \sphinxcode{\sphinxupquote{<expr>}} is \sphinxcode{\sphinxupquote{True}}. Otherwise, nothing happens. Also, note that \sphinxcode{\sphinxupquote{if y}} gets evaluated to \sphinxcode{\sphinxupquote{True}}. This is so because Python evaluates any integer value larger that is not zero as \sphinxcode{\sphinxupquote{True}} (we have also seen this in the previous chapter).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{5}

\PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{n}{y}\PYG{p}{:}           \PYG{c+c1}{\PYGZsh{} True}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}      
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
yes
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{y} \PYG{o}{\PYGZlt{}} \PYG{n}{x}\PYG{p}{:}           \PYG{c+c1}{\PYGZsh{} False}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x}\PYG{p}{:}               \PYG{c+c1}{\PYGZsh{} False}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{y}\PYG{p}{:}               \PYG{c+c1}{\PYGZsh{} True}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
yes
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the previous chapter, you have used the \sphinxcode{\sphinxupquote{and}}, \sphinxcode{\sphinxupquote{or}} and \sphinxcode{\sphinxupquote{not}} logical operators that evaluate to a boolean. You can also use these in the expression of your \sphinxcode{\sphinxupquote{if}} statement, as in the examples below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x} \PYG{o+ow}{or} \PYG{n}{y}\PYG{p}{:}          \PYG{c+c1}{\PYGZsh{} True}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
yes
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x} \PYG{o+ow}{and} \PYG{n}{y}\PYG{p}{:}         \PYG{c+c1}{\PYGZsh{} False}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{x}\PYG{p}{:}           \PYG{c+c1}{\PYGZsh{} True}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
yes
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Blocks}
\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student:blocks}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{<statement>}} that follows an \sphinxcode{\sphinxupquote{if}} condition in Python does not necessarily have to be just one line of code. In fact, you can add a \sphinxstyleemphasis{block} or \sphinxstyleemphasis{suite} of statements after your \sphinxcode{\sphinxupquote{if}} condition. As long as you stay at the same \sphinxstyleemphasis{indentation level}, these will be jointly executed with the first statement. For example, based on the cases above, we could have the following piece of code:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{y}\PYG{p}{:} 
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is a non\PYGZhy{}zero integer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{so I will print}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
y
is a non\PYGZhy{}zero integer
so I will print
yes
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here, all the print statements form a block of code at the same indentation level. Within a block, you can have additional if statements. For example, instead of writing \sphinxcode{\sphinxupquote{if x and y:}} as we did above, you could also write the following to get the exact same behavior. Notice that now we have added two levels of indentation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{n}{x}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{y}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{yes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Blocks can be nested to arbitrary depth, and depending on the expressions, some lines will be executed while others won’t.

\begin{sphinxadmonition}{note}{Exercise 3.1}

\sphinxAtStartPar
One of the lines in the following code is \sphinxstylestrong{not} executed. Which line is it?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{foo}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{foo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{baz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}       
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Outer condition is true}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}      

    \PYG{k}{if} \PYG{l+m+mi}{10} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20}\PYG{p}{:}                           
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Inner condition 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}        

    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Between inner conditions}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}     

    \PYG{k}{if} \PYG{l+m+mi}{10} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{:}                           
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Inner condition 2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}        

    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{End of outer condition}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}       
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{After outer condition}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}            
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{\sphinxstyleliteralintitle{\sphinxupquote{else}} and \sphinxstyleliteralintitle{\sphinxupquote{elif}}}
\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student:else-and-elif}}
\sphinxAtStartPar
As you might expect, where there’s an \sphinxcode{\sphinxupquote{if}} there can also be an \sphinxcode{\sphinxupquote{else}}. This \sphinxcode{\sphinxupquote{else}} is an expression which is evaluated as the opposite of the \sphinxcode{\sphinxupquote{if}} expression. The statement following this expression is what gets executed if the expression following \sphinxcode{\sphinxupquote{if}} is evaluated to be \sphinxcode{\sphinxupquote{False}}.

\sphinxAtStartPar
For example, take the following piece of code. In this case, the expression following \sphinxcode{\sphinxupquote{if}} is obviously \sphinxcode{\sphinxupquote{False}}, so the statement following \sphinxcode{\sphinxupquote{else}} will be executed and ‘smaller’ will be printed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{l+m+mi}{10} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{larger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smaller}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
smaller
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A third kind of expression is the \sphinxcode{\sphinxupquote{elif}} or ‘else if’ expression that can be used in case there are more than two possible outcomes. Following an \sphinxcode{\sphinxupquote{if}} expression, you can have any number of \sphinxcode{\sphinxupquote{elif}} expressions that you desire, potentially followed by an \sphinxcode{\sphinxupquote{else}} statement. Note that if the expression following \sphinxcode{\sphinxupquote{if}} is \sphinxcode{\sphinxupquote{True}}, none of the other expressions will actually be checked. Similarly, as soon as one of the \sphinxcode{\sphinxupquote{elif}} conditions is true, the other conditions will not be checked. The following provides an example of using \sphinxcode{\sphinxupquote{if}}, \sphinxcode{\sphinxupquote{elif}} and \sphinxcode{\sphinxupquote{else}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{language} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{french}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{if} \PYG{n}{language} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{english}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{language} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dutch}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hallo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{language} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{french}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bonjour}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{unknown language}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
bonjour
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 3.2}

\sphinxAtStartPar
In each of the following equations, evaluate the given code fragments. Investigate each of the fragments for the various starting values. Use Python to check your answer.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
What is the value of \sphinxcode{\sphinxupquote{m}} if\\
a) \sphinxcode{\sphinxupquote{n = 7}}\\
b) \sphinxcode{\sphinxupquote{n = 0}}\\
c) \sphinxcode{\sphinxupquote{n = \sphinxhyphen{}7}} ?

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{2}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
What is the value of \sphinxcode{\sphinxupquote{t}} if\\
a) \sphinxcode{\sphinxupquote{s = 1}}\\
b) \sphinxcode{\sphinxupquote{s = 7}}\\
c) \sphinxcode{\sphinxupquote{s = 57}}\\
d) \sphinxcode{\sphinxupquote{s = 300}}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k}{if} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{s}
    \PYG{k}{elif} \PYG{n}{s} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{9} \PYG{o}{\PYGZhy{}} \PYG{n}{s}
    \PYG{k}{elif} \PYG{n}{s} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{n}{s}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{n}{s}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
What is the value of \sphinxcode{\sphinxupquote{h}} if\\
a) \sphinxcode{\sphinxupquote{t = 50}}\\
b) \sphinxcode{\sphinxupquote{t = 19}}\\
c) \sphinxcode{\sphinxupquote{t = \sphinxhyphen{}6}}\\
d) \sphinxcode{\sphinxupquote{t = 0}}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k}{if} \PYG{n}{t} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{24}\PYG{p}{:}
        \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{t} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{k}{elif} \PYG{n}{t} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{9}\PYG{p}{:}
        \PYG{n}{h} \PYG{o}{=} \PYG{n}{t}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{t}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{h} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{t}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
What is the value of \sphinxcode{\sphinxupquote{y}} if\\
a) \sphinxcode{\sphinxupquote{x = \sphinxhyphen{}1}}\\
b) \sphinxcode{\sphinxupquote{x = 5}}\\
c) \sphinxcode{\sphinxupquote{x = 30}}\\
d) \sphinxcode{\sphinxupquote{x = 56}}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{k}{if} \PYG{l+m+mi}{0} \PYG{o}{\PYGZlt{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{7}\PYG{p}{:}
        \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{x}
    \PYG{k}{elif} \PYG{l+m+mi}{7} \PYG{o}{\PYGZlt{}} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{55}\PYG{p}{:}
        \PYG{n}{y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10} \PYG{o}{*} \PYG{n}{x}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{333}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.3}

\sphinxAtStartPar
A bank will offer a customer a loan if they are 21 or over and have an annual income of at least €21000. Write a Python script that contains the customer’s age and income in a dictionary. Depending on the age and income, one of the following lines should be printed (using the \sphinxcode{\sphinxupquote{print}} function):
\begin{itemize}
\item {} 
\sphinxAtStartPar
‘We are able to offer you a loan.’

\item {} 
\sphinxAtStartPar
‘Unfortunately at this time we are unable to offer you a loan.’

\end{itemize}

\sphinxAtStartPar
Verify your code by testing with
\begin{itemize}
\item {} 
\sphinxAtStartPar
A 40\sphinxhyphen{}year old man with an annual income of €11000

\item {} 
\sphinxAtStartPar
A 18\sphinxhyphen{}year old woman with an annual income of €25000

\item {} 
\sphinxAtStartPar
A 30\sphinxhyphen{}year old woman with an annual income of €40000

\item {} 
\sphinxAtStartPar
A 15\sphinxhyphen{}year old boy with an annual income of €5000

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.4}

\sphinxAtStartPar
Write a Python script that asks the user for two numbers and prints ‘The first number can be divided by the second number’ or ‘The first number cannot be divided by the second number’, depending on which is the case.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Conditional expression}

\sphinxAtStartPar
In addition to the syntax above, Python offers a compact way of writing binary \sphinxcode{\sphinxupquote{if}}/\sphinxcode{\sphinxupquote{else}} statements. This is called a \sphinxstyleemphasis{conditional expression} or \sphinxstyleemphasis{ternary operator} and means that the expression

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{l+m+mi}{10} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{larger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smaller}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
can also be written in one line of code as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{larger}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{if} \PYG{l+m+mi}{10} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20} \PYG{k}{else} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{smaller}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
It can in some cases be useful two write expressions like this, for example when you want to compactly assign a value to a variable.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coat} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{raincoat}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{raining} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jacket}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{\sphinxstyleliteralintitle{\sphinxupquote{while}} loops}
\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student:while-loops}}
\sphinxAtStartPar
Iteration control structures, loops, are used to repeat a block of statements until some condition is
met. Python supports two types of loops: the \sphinxcode{\sphinxupquote{while}}\sphinxhyphen{}loop and the \sphinxcode{\sphinxupquote{for}}\sphinxhyphen{}loop. A while loop executes some statement as long as a condition is \sphinxcode{\sphinxupquote{True}}. We call each time that the statement below \sphinxcode{\sphinxupquote{while}} is executed an ‘iteration’. As soon as the condition is \sphinxcode{\sphinxupquote{False}} the loop will stop iterating.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{while} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
    \PYG{n}{a} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
The animation below nicely visualizes how a \sphinxcode{\sphinxupquote{while}} loop works in this piece of code. As you can see, the \sphinxcode{\sphinxupquote{while}} statement is checked at the \sphinxstyleemphasis{beginning} of each iteration. If that is the case, the block below the \sphinxcode{\sphinxupquote{while}} statement is executed. If not, the loop ends.

\sphinxAtStartPar
\sphinxincludegraphics{{/Users/jmwolterink/Library/CloudStorage/OneDrive-UniversityofTwente/Teaching/TM/M3/intro-programming/jupyter-book/_build/.doctrees/images/4d69bb0160c6be7432aa8fa5e8a4078ca301b162/download}.gif}

\sphinxAtStartPar
You can use \sphinxcode{\sphinxupquote{while}} loops for situations in which you do not know beforehand how many iterations you need. For example, we can write a script that uses a \sphinxcode{\sphinxupquote{while}} loop to create the longest possible list of even numbers that together are less than 40.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{even\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{even\PYGZus{}numbers} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}


\PYG{k}{while} \PYG{n}{even\PYGZus{}sum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{:}
    \PYG{n}{even\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{n}
    \PYG{n}{even\PYGZus{}numbers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{n}{n} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{even\PYGZus{}sum}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{even\PYGZus{}numbers}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
42
[0, 2, 4, 6, 8, 10]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If you look closely at this example, you can see that \sphinxcode{\sphinxupquote{even\_sum}} is actually larger than 40. This is so because at the moment that \sphinxcode{\sphinxupquote{even\_sum < 40}} became \sphinxcode{\sphinxupquote{False}} (and the loop stopped), the last number \sphinxcode{\sphinxupquote{n}}=12 had already been added to \sphinxcode{\sphinxupquote{even\_numbers}}. Hence, we have to use slicing to exclude the last number in the print statement.

\sphinxAtStartPar
We could prevent this by using an \sphinxcode{\sphinxupquote{if}} expression and a \sphinxcode{\sphinxupquote{break}} statement. Once Python encounters a \sphinxcode{\sphinxupquote{break}}, it immediately exits whatever loop it is in. In this case, the code could be changed to the following.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{even\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{even\PYGZus{}numbers} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{while} \PYG{n}{even\PYGZus{}sum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{even\PYGZus{}sum} \PYG{o}{+} \PYG{n}{n} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Check if adding the current number n would let even\PYGZus{}sum exceed 40}
        \PYG{k}{break}              \PYG{c+c1}{\PYGZsh{} If that is the case, get out of the loop immediately}
    \PYG{k}{else}\PYG{p}{:}                  \PYG{c+c1}{\PYGZsh{} If not, continue looping}
        \PYG{n}{even\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{n}
        \PYG{n}{even\PYGZus{}numbers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
        \PYG{n}{n} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{even\PYGZus{}sum}\PYG{p}{)}        
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{even\PYGZus{}numbers}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
30
[0, 2, 4, 6, 8, 10]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In addition to \sphinxcode{\sphinxupquote{break}}, Python also contains a \sphinxcode{\sphinxupquote{continue}} statement. If Python encounters a \sphinxcode{\sphinxupquote{continue}} statement, it stays in the loop, but ends the current iteration. In our example, imagine that (for some reason) we do not want to include a number \sphinxcode{\sphinxupquote{n}} if it can be divided by 6. Then we can add an \sphinxcode{\sphinxupquote{elif}} statement to check this condition and skip the current iteration if the condition is met.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{even\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{even\PYGZus{}numbers} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{while} \PYG{n}{even\PYGZus{}sum} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{even\PYGZus{}sum} \PYG{o}{+} \PYG{n}{n} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Check if adding the current number n would let odd\PYGZus{}sum exceed 40}
        \PYG{k}{break}              \PYG{c+c1}{\PYGZsh{} If that is the case, get out of the loop immediately}
    \PYG{k}{elif} \PYG{n}{n} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{6} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}       \PYG{c+c1}{\PYGZsh{} If the number n can be divided by 6}
        \PYG{n}{n} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}             \PYG{c+c1}{\PYGZsh{} Increment the number}
        \PYG{k}{continue}           \PYG{c+c1}{\PYGZsh{} Move on to next iteration}
    \PYG{k}{else}\PYG{p}{:}                  \PYG{c+c1}{\PYGZsh{} If neither condition is met, continue looping}
        \PYG{n}{even\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{n}
        \PYG{n}{even\PYGZus{}numbers}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
        \PYG{n}{n} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{even\PYGZus{}sum}\PYG{p}{)}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{even\PYGZus{}numbers}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
38
[2, 4, 8, 10, 14]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Infinite loops}

\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{while}} loop will continue running as long as its condition is \sphinxcode{\sphinxupquote{True}}. That means that it’s also possible to make an infinite loop that causes your code to get stuck. For example, the following code will run forever if you don’t stop it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Running}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you make such a loop, always make sure that there is also a \sphinxcode{\sphinxupquote{break}} statement inside (in combination with an \sphinxcode{\sphinxupquote{if}}) so you an actually exit the loop. If you accidentally do end up in an infinite loop, you can in most terminals use Ctrl + c to shut down your script.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.5}

\sphinxAtStartPar
Write a script that determines the largest integer \(n\) for which \(1^3 + 2^3 + \cdots + n^3\) is less than 2000.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.6}

\sphinxAtStartPar
Write a guessing game where the user has to guess a secret number. After every guess the program tells the user whether their number was too large or too small. At the end of the game, the number of tries needed by the user should be printed. If a user adds the same number twice in a row, it counts as one try.

\sphinxAtStartPar
Start your script with the following code to define the secret number:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{random}

\PYG{n}{secret\PYGZus{}number} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} The rest of your code goes here}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{\sphinxstyleliteralintitle{\sphinxupquote{for}} loops}
\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student:for-loops}}
\sphinxAtStartPar
In contrast to a \sphinxcode{\sphinxupquote{while}}\sphinxhyphen{}loop, for which the number of iterations is not defined, in a \sphinxcode{\sphinxupquote{for}}\sphinxhyphen{}loop the number of iterations is fixed upon entering the loop. The standard for\sphinxhyphen{}loop has general syntax

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{sequence}\PYG{o}{\PYGZgt{}}\PYG{p}{:}
    \PYG{n}{do} \PYG{n}{something} 
\end{sphinxVerbatim}

\sphinxAtStartPar
Here, \sphinxcode{\sphinxupquote{<sequence>}} can be a list, set, tuple, dictionary, or string. For example, we can print all elements in the list \sphinxcode{\sphinxupquote{{[}1, 2, 3, 5, 8{]}}} as follows

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
2
3
5
8
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The for\sphinxhyphen{}loop iterates over something which we call an \sphinxstyleemphasis{iterable}: an object that is able to return its items one\sphinxhyphen{}by\sphinxhyphen{}one until no more items remain. For example, if we want to print ‘Hello world’ five times, we can make a list with five items (here digits) and iterate over that list.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello world}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello world
Hello world
Hello world
Hello world
Hello world
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that in the example above, we actually don’t do anything with the items in the list. We have here used integers in ascending order, but basically any item of any type will do. In contrast to other programming languages, Python does not use these integers as indices unless you want it to do so. We do have to give a name to the variable that holds the value coming from the list, but we could also use the ‘throwaway’ variable name \sphinxcode{\sphinxupquote{\_}}. To illustrate this, the previous result could also have been obtained with strings in a list.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{person}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{woman}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{man}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{camera}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello world}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello world
Hello world
Hello world
Hello world
Hello world
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now let’s say that we want to do something a 1000 times. For example, add all integers between 0 and 1000. You can imagine it would be very cumbersome to write out a list with 1000 integers to iterate over. Luckily, the built\sphinxhyphen{}in \sphinxcode{\sphinxupquote{range(start, stop, step)}} function in Python returns an iterable that provides numbers from \sphinxcode{\sphinxupquote{start}} to \sphinxcode{\sphinxupquote{stop}} with an interval of \sphinxcode{\sphinxupquote{step}}. Now, to print ‘Hello world’ 5 times, we simply use.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} 
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello world}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello world
Hello world
Hello world
Hello world
Hello world
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The arguments of the \sphinxcode{\sphinxupquote{range}} function work very similar to slicing that you have seen for lists and tuples. The function returns integers up to but not including the \sphinxcode{\sphinxupquote{stop}} argument. Moreover, step sizes can be negative. Take a look at the following examples.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{digit} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digit}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{digit} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digit}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{digit} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{digit}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0
1
2
3
4
\PYGZhy{}\PYGZhy{}\PYGZhy{}
1
3
5
7
\PYGZhy{}\PYGZhy{}\PYGZhy{}
9
8
7
6
5
4
3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As mentioned above, your \sphinxcode{\sphinxupquote{for}} loop can iterate over lists, tuples, sets, dictionaries, and strings. For example, we can loop over the letters in a string.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{some\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coffee}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{letter} \PYG{o+ow}{in} \PYG{n}{some\PYGZus{}string}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
c
o
f
f
e
e
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{\sphinxstyleliteralintitle{\sphinxupquote{break}} and \sphinxstyleliteralintitle{\sphinxupquote{continue}}}

\sphinxAtStartPar
Just like in a \sphinxcode{\sphinxupquote{while}} loop, you can use \sphinxcode{\sphinxupquote{break}} and \sphinxcode{\sphinxupquote{continue}} to exit the loop or skip iterations in a \sphinxcode{\sphinxupquote{for}} loop.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.7}

\sphinxAtStartPar
Write short scripts using loop constructions for the following tasks.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Determine the sum of the first 50 squared numbers with a loop.

\item {} 
\sphinxAtStartPar
Create a script with just one loop that calculates the sum of all entries of a vector \(x\) and also the vector of running sums (as a list). The running sum of a vector \(x\) of \(n\) entries is the vector of \(n\) entries defined as \([x_0, x_0+x_1, x_0+x_1+x_2, \cdots, x_0+x_1+\ldots+x_n]\). Test your code for x = \([1, 9, 1, 0, 4]\).

\end{enumerate}
\end{sphinxadmonition}


\section{Nested loops}
\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student:nested-loops}}
\sphinxAtStartPar
Just like we can \sphinxstyleemphasis{nest} conditional statements in blocks, we can also nest loops. For example, we can generate a multiplication table for numbers 1 to 5 with two nested loops.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{row} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{row}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{n}{j}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1, 2, 3, 4, 5]
[2, 4, 6, 8, 10]
[3, 6, 9, 12, 15]
[4, 8, 12, 16, 20]
[5, 10, 15, 20, 25]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There are no restrictions on kinds of loops that you nest: a \sphinxcode{\sphinxupquote{for}} loop can contain a \sphinxcode{\sphinxupquote{while}} loop and vice versa. Moreover, there are no restrictions on the number of loops that you nest (or the \sphinxstyleemphasis{depth}). You can, for example, nest three loops as follows.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{while} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{7}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}
            \PYG{n}{j} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 0 0
0 2 1
0 4 0
0 6 1
1 0 0
1 2 1
1 4 0
1 6 1
2 0 0
2 2 1
2 4 0
2 6 1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Simultaneously looping over two sequences}
\label{\detokenize{notebooks/03_ControlStructures/03_ControlStructures_student:simultaneously-looping-over-two-sequences}}
\sphinxAtStartPar
Sometimes you might want to loop over two sequences at the same time. An easy example is pairwise multiplication of two vectors: the aim is to compute a new vector in which each element is the product of the elements in the two input item at the same index. For this, you can use the \sphinxcode{\sphinxupquote{zip}} function that you have seen before and that acts like a zipper conjoining two lists. See below for an example

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Define an input vector as a list}
\PYG{n}{vector\PYGZus{}b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Define a second input vector}
\PYG{n}{vector\PYGZus{}c} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}        \PYG{c+c1}{\PYGZsh{} Define an output vector }

\PYG{k}{for} \PYG{n}{elem\PYGZus{}a}\PYG{p}{,} \PYG{n}{elem\PYGZus{}b} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{vector\PYGZus{}a}\PYG{p}{,} \PYG{n}{vector\PYGZus{}b}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Jointly iterate over the two input vectors}
    \PYG{n}{vector\PYGZus{}c}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{elem\PYGZus{}a} \PYG{o}{*} \PYG{n}{elem\PYGZus{}b}\PYG{p}{)}           \PYG{c+c1}{\PYGZsh{} Append product of elements to output vector}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{vector\PYGZus{}c}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[6, 24, 40]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 3.8}

\sphinxAtStartPar
Write a script that does the following
\begin{itemize}
\item {} 
\sphinxAtStartPar
ask the user for a number \(n\)

\item {} 
\sphinxAtStartPar
give the user the choice between computing the sum and computing the product of \(1,\ldots,n\)

\item {} 
\sphinxAtStartPar
compute the desired result

\item {} 
\sphinxAtStartPar
print the result for the user

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 3.9}

\sphinxAtStartPar
Write a program that uses loops to compute \sphinxhref{https://en.wikipedia.org/wiki/Fibonacci\_sequence}{Fibonacci numbers} (as in Exercise 1.12). The scripts asks the user how many numbers should be computed. This can be \sphinxstylestrong{any} number, so your code should be flexible.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Functions}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:functions}}\label{\detokenize{notebooks/04_Functions/04_Functions_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
define a function in Python

\item {} 
\sphinxAtStartPar
understand the concept of scope, local and global variables

\item {} 
\sphinxAtStartPar
create a function with one or more input arguments and one or more output arguments

\item {} 
\sphinxAtStartPar
understand what recursion is and how to use it

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
By now you can write and run a Python script, you can write conditional statements using \sphinxcode{\sphinxupquote{if}}, \sphinxcode{\sphinxupquote{elif}} and \sphinxcode{\sphinxupquote{else}}, and you can write \sphinxcode{\sphinxupquote{for}} and \sphinxcode{\sphinxupquote{while}} loops. You can ask the user for input to dynamically change what happens in a script. You’ve seen that with these building blocks, you can already solve some problems and write small programs. However, if you write scripts with only these building blocks, they can become quite lengthy. Most programming languages use \sphinxstylestrong{functions}. In Python, functions are everywhere. In fact, you have already used functions: for example, the \sphinxcode{\sphinxupquote{print()}} function outputs something to the screen. We \sphinxstyleemphasis{call} this function with some input, and it writes this input to the terminal.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Goodbye}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello
Goodbye
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Other functions that you have used so far are \sphinxcode{\sphinxupquote{len()}} and \sphinxcode{\sphinxupquote{input()}}. You can think of a function as a mini\sphinxhyphen{}program that runs within another program or within another function. The main program calls the mini\sphinxhyphen{}program and sends information that the mini\sphinxhyphen{}program will need as it runs. When the function completes all of its actions, it may send some data back to the main program that has called it. The primary purpose of a function is to allow you to reuse the code within it whenever you need it, using different inputs if required. When you use functions, you are extending your Python vocabulary. This lets you express the solution to your problem in a clearer and more succinct way. Functions can be used many times within one script. For example, when training a neural network, you call the same functions thousands or millions of times.


\section{A basic function}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:a-basic-function}}
\sphinxAtStartPar
Let’s start by defining a very simple function. The \sphinxstyleemphasis{header} of a function always starts with the keyword \sphinxcode{\sphinxupquote{def}}, followed by the name of the function, parentheses, and a colon \sphinxcode{\sphinxupquote{:}}. The \sphinxstyleemphasis{body} of a function contains the actual Python lines that will be executed. The body is a \sphinxstyleemphasis{block} of code with indentation, just like the statement if you use \sphinxcode{\sphinxupquote{if}} or \sphinxcode{\sphinxupquote{for}}. We can define a function that simply writes ‘Hello world’ to the terminal.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{hello\PYGZus{}world}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}        \PYG{c+c1}{\PYGZsh{} This is the header of the function}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello world}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} This is the body of the function}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Defining a function does not lead to any output. The function is simply there, but not used. To use the function we have to \sphinxstyleemphasis{call} it, like this:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hello\PYGZus{}world}\PYG{p}{(}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{} Call the hello\PYGZus{}world function}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello world
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
By calling the function, it’s body gets executed. In this case, the body of the function only contains a call to the built\sphinxhyphen{}in \sphinxcode{\sphinxupquote{print}} function. This also shows that you can call functions from within other functions.

\begin{sphinxadmonition}{note}{The use of \sphinxstyleliteralintitle{\sphinxupquote{(}} and \sphinxstyleliteralintitle{\sphinxupquote{)}}}

\sphinxAtStartPar
Any time you \sphinxstyleemphasis{call} a function (i.e., use it), you have to use a \sphinxcode{\sphinxupquote{(}} and a \sphinxcode{\sphinxupquote{)}}. Note that this is different from \sphinxstyleemphasis{indexing} a list, tuple, dictionary, for which you use \sphinxcode{\sphinxupquote{{[}}} and \sphinxcode{\sphinxupquote{{]}}}.
\end{sphinxadmonition}


\section{Where do you put a function?}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:where-do-you-put-a-function}}
\sphinxAtStartPar
So far, you’ve written Python scripts as \sphinxcode{\sphinxupquote{.py}} files. You can simply add functions to your script so that they can be used in that script. For example, the following would be a valid \sphinxcode{\sphinxupquote{.py}} file that you can run in VS Code. Try it out!

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{hello\PYGZus{}world}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}        \PYG{c+c1}{\PYGZsh{} This is the header of the function}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello world}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} This is the body of the function}
    
\PYG{n}{hello\PYGZus{}world}\PYG{p}{(}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{} Call the hello\PYGZus{}world function}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hello world
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
It is important that you define your functions \sphinxstylestrong{before} you use them. Otherwise, the interpreter does not understand which function you’re referring to. So, the following will not work:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hello\PYGZus{}world}\PYG{p}{(}\PYG{p}{)}             \PYG{c+c1}{\PYGZsh{} We\PYGZsq{}re trying to call the hello\PYGZus{}world function, but it has not been defined}

\PYG{k}{def} \PYG{n+nf}{hello\PYGZus{}world}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}        
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hello world}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Function naming conventions}

\sphinxAtStartPar
In Python, naming conventions for functions are the same as for variables. You should use lowercase letters, and separate words with an underscore, as in the \sphinxcode{\sphinxupquote{print\_lines()}} example above. Since functions represent actions, it’s a best practice to start your function names with a verb to make your code more readable.
\end{sphinxadmonition}


\section{Functions with arguments}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:functions-with-arguments}}
\sphinxAtStartPar
Things get more interesting if our function does not do exactly the same whenever it is called, but changes what it does depending on the input that we provide. For example, we can write a function that takes two numbers and decides which of the two numbers is smallest. For this, we use things that you have already learned: e.g, \sphinxcode{\sphinxupquote{if}}, \sphinxcode{\sphinxupquote{elif}}, \sphinxcode{\sphinxupquote{else}}, string formatting.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{find\PYGZus{}smallest}\PYG{p}{(}\PYG{n}{number\PYGZus{}a}\PYG{p}{,} \PYG{n}{number\PYGZus{}b}\PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} The header of the function with two parameters}
    \PYG{k}{if} \PYG{n}{number\PYGZus{}a} \PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}b}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ is the smallest number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{number\PYGZus{}a}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{number\PYGZus{}b} \PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}a}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ is the smallest number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{number\PYGZus{}b}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Both numbers are equal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
This function has two \sphinxstyleemphasis{parameters}: \sphinxcode{\sphinxupquote{number\_a}} and \sphinxcode{\sphinxupquote{number\_b}}. These parameters are used in the body of the function, in this case in an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}statement with comparison operators \sphinxcode{\sphinxupquote{<}}. Now, if we want to use this function, we have to \sphinxstyleemphasis{call} it using \sphinxstyleemphasis{arguments}, i.e., values for the parameters, as follows:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{find\PYGZus{}smallest}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{number\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{23}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} Call the function using two arguments}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
23 is the smallest number
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In general, you can call a function with any type of variable. Arguments can also be lists, tuples, dictionaries, etc. However, there is a chance that your type is not compatible with the type that the function was intended for. In that case, Python will throw an exception. You can help others reading your code by \sphinxstyleemphasis{type hinting}: indicating in your function header which type is expected. For the \sphinxcode{\sphinxupquote{find\_smallest()}} function this might look like the following.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{find\PYGZus{}smallest}\PYG{p}{(}\PYG{n}{number\PYGZus{}a}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{number\PYGZus{}b}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{number\PYGZus{}a} \PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}b}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ is the smallest number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{number\PYGZus{}a}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{number\PYGZus{}b} \PYG{o}{\PYGZlt{}} \PYG{n}{number\PYGZus{}a}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ is the smallest number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{number\PYGZus{}b}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Both numbers are equal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that type hinting is a form of documentation: it doesn’t change how Python treats your code, but it makes your code more reusable, just like placing comments with \sphinxcode{\sphinxupquote{\#}} and using descriptive names for variables and functions.

\begin{sphinxadmonition}{note}{Exercise 4.1}

\sphinxAtStartPar
Consider \sphinxstyleemphasis{Exercise 3.3} about banking. Adapt that script into a function called \sphinxcode{\sphinxupquote{evaluate\_customer}} that takes in a customers age (as \sphinxcode{\sphinxupquote{int}}) and annual income (as \sphinxcode{\sphinxupquote{int}}) as parameters and prints the required answer. Test your code by calling the function as follows

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{evaluate\PYGZus{}customer}\PYG{p}{(}\PYG{n}{age}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{annual\PYGZus{}income}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{} The body of the function goes here}

\PYG{n}{evaluate\PYGZus{}customer}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{11000}\PYG{p}{)}
\PYG{n}{evaluate\PYGZus{}customer}\PYG{p}{(}\PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mi}{25000}\PYG{p}{)}
\PYG{n}{evaluate\PYGZus{}customer}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{40000}\PYG{p}{)}
\PYG{n}{evaluate\PYGZus{}customer}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{5000}\PYG{p}{)}    
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 4.2}

\sphinxAtStartPar
Write a function \sphinxcode{\sphinxupquote{print\_code}} that takes a ‘code’ as input and uses that code to print characters to the command line. A code is a string that describes which characters should be printed. Each code consists of pairs of \sphinxstyleemphasis{characters} and \sphinxstyleemphasis{counts}. The maximum count is 9. For example,
\begin{itemize}
\item {} 
\sphinxAtStartPar
when calling \sphinxcode{\sphinxupquote{print\_code('6+')}} the function should print \sphinxcode{\sphinxupquote{++++++}}

\item {} 
\sphinxAtStartPar
when calling \sphinxcode{\sphinxupquote{print\_code('2+4*5+')}} the function should print \sphinxcode{\sphinxupquote{++****+++++}}

\item {} 
\sphinxAtStartPar
when calling \sphinxcode{\sphinxupquote{print\_code('2*4+6*')}} the function should print \sphinxcode{\sphinxupquote{**++++******}},

\item {} 
\sphinxAtStartPar
when calling \sphinxcode{\sphinxupquote{print\_code('9a4b3c')}} the function should print \sphinxcode{\sphinxupquote{aaaaaaaaabbbbccc}}

\end{itemize}

\sphinxAtStartPar
To help you get started, here is a layout for your function. You have to change the commented lines in order to make the function work.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{print\PYGZus{}code}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{output} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{for} \PYG{n}{start\PYGZus{}ind} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fragment} \PYG{o}{=} \PYG{n}{code}\PYG{p}{[}\PYG{n}{start\PYGZus{}ind}\PYG{p}{:}\PYG{n}{start\PYGZus{}ind}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} based on the fragment, extend the output string}
    \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} print the output string}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Finish this function and verify that your function works using the examples shown above.

\item {} 
\sphinxAtStartPar
The list below contains multiple codes. Write a script that loops over this list and prints each code. Note that these codes contain spaces. These are treated like characters by Python.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{full\PYGZus{}code} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 5 6+7 6+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 3 9+1+3 9+1+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 1 9+4+1 9+4+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 9+9+9+2+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 9+9+9+2+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 9+9+9+2+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 1 9+9+9+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 3 9+9+5+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 5 9+9+1+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 7 9+6+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 9 9+2+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 9 2 7+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{9 9 4 3+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{enumerate}
\end{sphinxadmonition}


\section{Return}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:return}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{print\_lines}}, \sphinxcode{\sphinxupquote{find\_smallest}}, and \sphinxcode{\sphinxupquote{print\_code}} functions only print a result, but do not \sphinxstyleemphasis{return} anything. In many cases, you will want to use a function to give you some output value that you can use in your script, instead of only writing the answer to the terminal. In Python, we use the keyword \sphinxcode{\sphinxupquote{return}} to send the result of the function call back to wherever the function was called from. Let’s make a very basic function that adds two numbers and returns the result.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{number\PYGZus{}a}\PYG{p}{,} \PYG{n}{number\PYGZus{}b}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{number\PYGZus{}a} \PYG{o}{+} \PYG{n}{number\PYGZus{}b}

\PYG{n}{sum\PYGZus{}of\PYGZus{}numbers} \PYG{o}{=} \PYG{n}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{n}{number\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{21}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} The result of the function call is stored in sum\PYGZus{}of\PYGZus{}numbers}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The sum is }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{sum\PYGZus{}of\PYGZus{}numbers}\PYG{p}{)}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} We can printthe value of sum\PYGZus{}of\PYGZus{}numbers (or use it for something else)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
The sum is 55
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
When we call this function, the sum of both numbers is computed and immediately returned. It then takes the place of \sphinxcode{\sphinxupquote{add\_numbers(number\_a = 34, number\_b = 21)}}, which means that the line now says

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sum\PYGZus{}of\PYGZus{}numbers} \PYG{o}{=} \PYG{l+m+mi}{55}
\end{sphinxVerbatim}

\sphinxAtStartPar
and that the result is directly assigned to the variable \sphinxcode{\sphinxupquote{sum\_of\_numbers}}.

\sphinxAtStartPar
A function can return more than one value. Values to be returned should be separated by a comma, and the output of the function should be assigned to the same number of variables. For example, we can write a function that returns two values: the sum and the product of its inputs.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{compute\PYGZus{}sum\PYGZus{}and\PYGZus{}product}\PYG{p}{(}\PYG{n}{number\PYGZus{}a}\PYG{p}{,} \PYG{n}{number\PYGZus{}b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{sum\PYGZus{}of\PYGZus{}numbers} \PYG{o}{=} \PYG{n}{number\PYGZus{}a} \PYG{o}{+} \PYG{n}{number\PYGZus{}b}
    \PYG{n}{product\PYGZus{}of\PYGZus{}numbers} \PYG{o}{=} \PYG{n}{number\PYGZus{}a} \PYG{o}{*} \PYG{n}{number\PYGZus{}b}
    \PYG{k}{return} \PYG{n}{sum\PYGZus{}of\PYGZus{}numbers}\PYG{p}{,} \PYG{n}{product\PYGZus{}of\PYGZus{}numbers}         \PYG{c+c1}{\PYGZsh{} Return two values, separated by ,}

\PYG{n}{summed}\PYG{p}{,} \PYG{n}{multiplied} \PYG{o}{=} \PYG{n}{compute\PYGZus{}sum\PYGZus{}and\PYGZus{}product}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Assign result of the function call to two variables}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{summed}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{multiplied}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
12
32
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Returning \sphinxstyleliteralintitle{\sphinxupquote{pass}}}

\sphinxAtStartPar
In some cases \sphinxhyphen{} when you’re coding \sphinxhyphen{} it might be convenient not to return anything at all but to already type the header of a function. To make sure that your code runs, each function \sphinxstylestrong{must} return something, but what do you return if the function isn’t finished? A solution is to return \sphinxcode{\sphinxupquote{pass}}, which can be used as a placeholder for future code. Note that this can also be used in control structures like \sphinxcode{\sphinxupquote{if}}, \sphinxcode{\sphinxupquote{else}}, and loops.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{unfinished\PYGZus{}function}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{k}{pass}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Optional arguments}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:optional-arguments}}
\sphinxAtStartPar
Python differentiates between \sphinxstyleemphasis{required} and \sphinxstyleemphasis{optional} arguments. Required arguments \sphinxstyleemphasis{should} always be provided to the function. If they are not provided, Python throws an error. Consider our \sphinxcode{\sphinxupquote{add\_numbers()}} function above: it has exactly two parameters: \sphinxcode{\sphinxupquote{number\_a}} and \sphinxcode{\sphinxupquote{number\_b}}. If fewer or more arguments are provided, Python throws an error:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{TypeError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{folders}\PYG{o}{/}\PYG{l+m+mi}{07}\PYG{o}{/}\PYG{n}{x0gf6dj176dfjvrn357t5p6h0000gn}\PYG{o}{/}\PYG{n}{T}\PYG{o}{/}\PYG{n}{ipykernel\PYGZus{}46846}\PYG{o}{/}\PYG{l+m+mf}{2140094660.}\PYG{n}{py} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n+ne}{TypeError}: add\PYGZus{}numbers() missing 1 required positional argument: \PYGZsq{}number\PYGZus{}b\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{number\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}/var/folders/07/x0gf6dj176dfjvrn357t5p6h0000gn/T/ipykernel\PYGZus{}46846/3779491282.py\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{1}
    \PYG{n}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{number\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
                                           \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: positional argument follows keyword argument
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In this example,\sphinxcode{\sphinxupquote{number\_a}} and \sphinxcode{\sphinxupquote{number\_b}} are both required arguments. Because of this, we actually don’t have to specify which parameter we’re assigning the argument to when we call the function. We can call the function \sphinxstyleemphasis{with} or \sphinxstyleemphasis{without} parameter names.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{n}{number\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{75}\PYG{p}{)} \PYG{o}{==} \PYG{n}{add\PYGZus{}numbers}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{75}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A way to make your code more flexible is to use \sphinxstyleemphasis{optional} arguments. If these are not provided, the function still runs. This is because we provide \sphinxstyleemphasis{default} parameter values: if the user does not provide other values, these are used. Consider the following variant on our function, which assumes that \sphinxcode{\sphinxupquote{number\_b = 37}} if not provided.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}numbers\PYGZus{}optional}\PYG{p}{(}\PYG{n}{number\PYGZus{}a}\PYG{p}{,} \PYG{n}{number\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{number\PYGZus{}a} \PYG{o}{+} \PYG{n}{number\PYGZus{}b}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}numbers\PYGZus{}optional}\PYG{p}{(}\PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{52}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}numbers\PYGZus{}optional}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
86
49
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To prevent ambiguity about the correspondence between parameters and arguments, it’s good to use parameter names when calling a function, like this:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}numbers\PYGZus{}optional}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{n}{number\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{52}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
86
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
It is important that if you provide default values for arguments, that this should be done for the last parameter, second\sphinxhyphen{}to\sphinxhyphen{}last, etc. The parameter list of your function cannot have a required argument after an optional one.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}numbers\PYGZus{}optional}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{n}{number\PYGZus{}b}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{number\PYGZus{}a} \PYG{o}{+} \PYG{n}{number\PYGZus{}b}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}numbers\PYGZus{}optional}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{n}{number\PYGZus{}b} \PYG{o}{=} \PYG{l+m+mi}{52}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}/var/folders/07/x0gf6dj176dfjvrn357t5p6h0000gn/T/ipykernel\PYGZus{}46846/1073581284.py\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{1}
    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}numbers\PYGZus{}optional}\PYG{p}{(}\PYG{n}{number\PYGZus{}a} \PYG{o}{=} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{n}{number\PYGZus{}b}\PYG{p}{)}\PYG{p}{:}
                            \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: non\PYGZhy{}default argument follows default argument
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 4.3}

\sphinxAtStartPar
A common operation in linear algebra is computing the dot product between two vectors. The dot vector of two vectors \(\mathbf{a}=[a_1, a_2, \ldots, a_n]\) and \(\mathbf{b}=[b_1, b_2, \ldots, b_n]\) is defined as
\begin{equation*}
\begin{split}\mathbf{a} \cdot \mathbf{b} = \sum_{i=1}^n a_i b_i\end{split}
\end{equation*}
\sphinxAtStartPar
Write a function that takes two vectors \(\mathbf{a}\) and \(\mathbf{b}\) as lists as input and returns their dot product as a floating point number. The dot product can only be computed if the length of \(\mathbf{a}\) and \(\mathbf{b}\) is the same. Let your function check that this is the case, and if not, print a message for the user and return \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}. Call your function \sphinxcode{\sphinxupquote{dot\_product()}} and use the code below to test it

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}
\PYG{n}{vector\PYGZus{}b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dot\PYGZus{}product}\PYG{p}{(}\PYG{n}{vector\PYGZus{}a}\PYG{p}{,} \PYG{n}{vector\PYGZus{}b}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{vector\PYGZus{}a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n}{vector\PYGZus{}b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dot\PYGZus{}product}\PYG{p}{(}\PYG{n}{vector\PYGZus{}a}\PYG{p}{,} \PYG{n}{vector\PYGZus{}b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Scope}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:scope}}
\sphinxAtStartPar
Each variable in Python has a \sphinxcode{\sphinxupquote{scope}}. This influences the way that variables are looked up in your code. So far, we have worked with global variables. These are variables that can be accessed anywhere in the code. Setting the value of the variable in a \sphinxcode{\sphinxupquote{for}} or \sphinxcode{\sphinxupquote{while}} loop or in an \sphinxcode{\sphinxupquote{if}}\sphinxhyphen{}statement changes the value everywhere. When working with functions, we have to consider the scope of a variable. This means that if a variable is defined in a function, it cannot be accessed outside of that function.

\sphinxAtStartPar
Take a look at the following example. We have defined a simple function \sphinxcode{\sphinxupquote{add\_y}} that adds some number to its input. The function works well and we can verify this with the first print statement. The number that is added is defined in a \sphinxstyleemphasis{local} variable \sphinxcode{\sphinxupquote{y}}. This variable only exists within the function \sphinxcode{\sphinxupquote{add\_y}}. If we want to print the value at the \sphinxstyleemphasis{global} level with \sphinxcode{\sphinxupquote{print(y)}} Python gives a \sphinxcode{\sphinxupquote{NameError}}: it cannot find the variable \sphinxcode{\sphinxupquote{y}} because it does not exist globally.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}y}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{8}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}y}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
18
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{folders}\PYG{o}{/}\PYG{l+m+mi}{07}\PYG{o}{/}\PYG{n}{x0gf6dj176dfjvrn357t5p6h0000gn}\PYG{o}{/}\PYG{n}{T}\PYG{o}{/}\PYG{n}{ipykernel\PYGZus{}46846}\PYG{o}{/}\PYG{l+m+mf}{1922670122.}\PYG{n}{py} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{4} 
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{5} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}y}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{6} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}

\PYG{n+ne}{NameError}: name \PYGZsq{}y\PYGZsq{} is not defined
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This also works the other way: if we define a global variable \sphinxcode{\sphinxupquote{y}}, the function will ignore its value and just use the local variable \sphinxcode{\sphinxupquote{y}} as long as it’s defined. Here, we see that although our global variable \sphinxcode{\sphinxupquote{y}} is 4 and remains 4, the value of \sphinxcode{\sphinxupquote{y}} in the function is 5.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{4}

\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}y}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{8}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}y}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
18
4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
However, if there is no \sphinxstyleemphasis{local} variable \sphinxcode{\sphinxupquote{y}} in the function, the global variable \sphinxcode{\sphinxupquote{y}} will be used instead, as below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{4}

\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}y}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{add\PYGZus{}y}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
14
4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
There is a particular priority system that Python uses to look up the value of a variable, the LEGB\sphinxhyphen{}rule. This stands for local, enclosed, global, built\sphinxhyphen{}in.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Local: these are variables that are defined only in a function.

\item {} 
\sphinxAtStartPar
Enclosed: an (inner) function can be defined inside another (outer) function. The inner function is able to access the variables of the outer function, but not the other way around.

\item {} 
\sphinxAtStartPar
Global: global variables at the level of your script.

\item {} 
\sphinxAtStartPar
Some variable names are \sphinxcode{\sphinxupquote{built\sphinxhyphen{}in}} and are always accessible from everywhere. These are the keywords that you have seen before and which you should never overwrite. These are:

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{keywords_c8hxf4}.png}

\sphinxAtStartPar
If the interpreter looks for the value of a variable, it does so bottom\sphinxhyphen{}up, starting at the local level. The figures below nicely visualize this process. Here, \sphinxcode{\sphinxupquote{x}} is defined within the inner function, so that is the value that is used at that point. Were it not, then \sphinxcode{\sphinxupquote{x}} in the outer function would be used. If that variable had not been defined, a global variable \sphinxcode{\sphinxupquote{x}} would be used. And if that didn’t work, the interpreter would look for a built\sphinxhyphen{}in variable \sphinxcode{\sphinxupquote{x}} (which does not exist).

\sphinxAtStartPar
\sphinxincludegraphics{{code_dmeddc}.png}
\sphinxincludegraphics{{Scope_fbrzcw}.png}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vector\PYGZus{}a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}
\PYG{n}{vector\PYGZus{}b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dot\PYGZus{}product}\PYG{p}{(}\PYG{n}{vector\PYGZus{}a}\PYG{p}{,} \PYG{n}{vector\PYGZus{}b}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{o}{/}\PYG{n}{var}\PYG{o}{/}\PYG{n}{folders}\PYG{o}{/}\PYG{l+m+mi}{07}\PYG{o}{/}\PYG{n}{x0gf6dj176dfjvrn357t5p6h0000gn}\PYG{o}{/}\PYG{n}{T}\PYG{o}{/}\PYG{n}{ipykernel\PYGZus{}46846}\PYG{o}{/}\PYG{l+m+mf}{896397102.}\PYG{n}{py} \PYG{o+ow}{in} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{1} \PYG{n}{vector\PYGZus{}a} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{2} \PYG{n}{vector\PYGZus{}b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{3.2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{3} \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dot\PYGZus{}product}\PYG{p}{(}\PYG{n}{vector\PYGZus{}a}\PYG{p}{,} \PYG{n}{vector\PYGZus{}b}\PYG{p}{)}\PYG{p}{)}

\PYG{n+ne}{NameError}: name \PYGZsq{}dot\PYGZus{}product\PYGZsq{} is not defined
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} }
\PYG{n}{prime} \PYG{o}{=} \PYG{n}{is\PYGZus{}prime}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{prime}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ is a prime number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ is not a prime number}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{  File}\PYG{n+nn}{ \PYGZdq{}/var/folders/07/x0gf6dj176dfjvrn357t5p6h0000gn/T/ipykernel\PYGZus{}46846/726729786.py\PYGZdq{}}\PYG{g+gt}{, line }\PYG{l+m+mi}{1}
    \PYG{n}{n} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{}}
          \PYG{o}{\PYGZca{}}
\PYG{n+ne}{SyntaxError}: invalid syntax
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Recursive functions}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:recursive-functions}}
\sphinxAtStartPar
We can call functions from anywhere, and we can even call a function from within itself. In Python (and in many other languages) there is no reason why a function cannot be called from within itself. This is called a \sphinxstyleemphasis{recursive} function. Recursion is a concept that can be difficult to understand. The core idea is that you repeatedly call the same function from within itself. This means that the operations that you’re applying should be very similar each time the function is called. A well\sphinxhyphen{}known example is the factorial \(n!=n \times n-1 \times n-2 \times \cdots \times 2 \times 1\). We can implement this in a recursive function as

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{factorial}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}                   \PYG{c+c1}{\PYGZsh{} 1}
    \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}                       \PYG{c+c1}{\PYGZsh{} 2}
        \PYG{k}{return} \PYG{n}{n} \PYG{o}{*} \PYG{n}{factorial}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} 3}
    \PYG{k}{else}\PYG{p}{:}                           \PYG{c+c1}{\PYGZsh{} 4}
        \PYG{k}{return} \PYG{l+m+mi}{1}                    \PYG{c+c1}{\PYGZsh{} 5}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{factorial}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Exercise 4.4}

\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{factorial()}} function above, we have added line numbers in comments. Look at the code and see if you can figure out in which order the lines are executed if you call \sphinxcode{\sphinxupquote{factorial(3)}}.
\end{sphinxadmonition}

\sphinxAtStartPar
To write a proper recursive function, you need an \sphinxcode{\sphinxupquote{if}} and \sphinxcode{\sphinxupquote{else}} expression, where each one corresponds to one of the two scenarions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A ‘base’ condition. This is the point at which the recursion stops and moves back ‘up’.

\item {} 
\sphinxAtStartPar
A change that is applied so that your process comes closer to reaching the base condition.

\end{enumerate}

\sphinxAtStartPar
In the example above, the base condition is \(n=1\), and the change that is applied is \(n-1\). If there is no base condition or no change, your function will just run indefinitely, like a \sphinxcode{\sphinxupquote{while}} loop without a stopping condition.

\begin{sphinxadmonition}{note}{Exercise 4.5}

\sphinxAtStartPar
Write a function \sphinxcode{\sphinxupquote{sum\_recursion}} to calculate the sum of a list of numbers using recursion.\\
\sphinxstylestrong{Hint}: In your base condition, there is only one item left in the list.

\sphinxAtStartPar
Test your function using the following code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sum\PYGZus{}recursion}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Your function body}
    
\PYG{n}{numbers\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n}{summed\PYGZus{}list} \PYG{o}{=} \PYG{n}{sum\PYGZus{}recursion}\PYG{p}{(}\PYG{n}{numbers\PYGZus{}list}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The sum of }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ is }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{numbers\PYGZus{}list}\PYG{p}{,} \PYG{n}{summed\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Built\sphinxhyphen{}in functions}
\label{\detokenize{notebooks/04_Functions/04_Functions_student:built-in-functions}}
\sphinxAtStartPar
You don’t have to define each function yourself: Python has a number of built\sphinxhyphen{}in functions that are available in any Python distribution. Useful functions include the \sphinxcode{\sphinxupquote{len}}, \sphinxcode{\sphinxupquote{print}} and \sphinxcode{\sphinxupquote{input}} functions that you have already used. In addition to the functions that you can write yourself, Python has a number of \sphinxstyleemphasis{built\sphinxhyphen{}in} functions. These are functions that are always available if you program in Python. Examples are \sphinxcode{\sphinxupquote{print()}}. A complete list of built\sphinxhyphen{}in functions is available \sphinxhref{https://docs.python.org/3/library/functions.html}{here}. Take a look, you’ll likely recognize some of them. We have previously used the \sphinxcode{\sphinxupquote{round()}} and \sphinxcode{\sphinxupquote{range()}} functions, and it’s clear what \sphinxhyphen{} for example \sphinxhyphen{} the \sphinxcode{\sphinxupquote{abs()}} does. Likewise, you have used the \sphinxcode{\sphinxupquote{type()}} function to find out what the type of a variable is.

\begin{sphinxadmonition}{note}{Exercise 4.6}

\sphinxAtStartPar
There are many cases in programming where we need to sort something, usually in ascending order (low to high), sometimes in descending order (high to low). There are also many different sorting algorithms, some faster than others, some more complex. The animation below visualizes nine popular sorting algorithms.

\sphinxAtStartPar
\sphinxincludegraphics{{/Users/jmwolterink/Library/CloudStorage/OneDrive-UniversityofTwente/Teaching/TM/M3/intro-programming/jupyter-book/_build/.doctrees/images/622f2114cee521a011ba73fd5ddf79db6f8944d4/download}.gif}

\sphinxAtStartPar
In this exercise, you will implement \sphinxstyleemphasis{bubble sort}. Bubble sort is not the fastest algorithm (as you can see in the animation), but it is (relatively) easy to understand. Let’s say that we have a list of numbers that we want to sort. Then bubble sort does the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Check if the first element in the list is greater than the next element in the list.

\item {} 
\sphinxAtStartPar
If it is greater, swap the two elements. Otherwise, repeat step 1. for the next element in the list.

\item {} 
\sphinxAtStartPar
Repeat 1 and 2 until you reach the end of the list.

\item {} 
\sphinxAtStartPar
Check if all elements are sorted.

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
If not, repeat the process in step 1 to 3. However, you can now ignore the last element because you know it has the highest value and is in the right place. The next iteration you can ignore the last two elements, etc.

\item {} 
\sphinxAtStartPar
If yes, the final output is a sorted array.

\end{itemize}

\sphinxAtStartPar
The animation below visualizes bubble sort for a short list.

\sphinxAtStartPar
\sphinxincludegraphics{{/Users/jmwolterink/Library/CloudStorage/OneDrive-UniversityofTwente/Teaching/TM/M3/intro-programming/jupyter-book/_build/.doctrees/images/c92d72a5cd58d35643cf71e87197775b907855d8/Bubble-sort-example-300px}.gif}

\sphinxAtStartPar
Your task in this exercise is to implement a bubble sort function. Use the provided code below and fill in the missing parts.\\
\sphinxstylestrong{Hint} Use a \sphinxcode{\sphinxupquote{while}} loop to check whether the list is sorted. You can use the provided \sphinxcode{\sphinxupquote{check\_sorted}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k}{def} \PYG{n+nf}{check\PYGZus{}sorted}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{numbers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{numbers}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
            \PYG{k}{return} \PYG{k+kc}{False}
    \PYG{k}{return} \PYG{k+kc}{True}

\PYG{k}{def} \PYG{n+nf}{bubble\PYGZus{}sort}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Your code goes here}
        


\PYG{n}{numbers} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{permutation}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The list of numbers }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ sorted}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{check\PYGZus{}sorted}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{)} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is not}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sorted\PYGZus{}numbers} \PYG{o}{=} \PYG{n}{bubble\PYGZus{}sort}\PYG{p}{(}\PYG{n}{numbers}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{sorted\PYGZus{}numbers}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The list of numbers }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s1}{ sorted}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{check\PYGZus{}sorted}\PYG{p}{(}\PYG{n}{sorted\PYGZus{}numbers}\PYG{p}{)} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is not}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Exercise 4.7}

\sphinxAtStartPar
Write a Python function that takes a number \(n\) as a parameter and returns \sphinxstylestrong{all prime numbers up to \(n\)} as a list. Tip: you can consider \sphinxhref{https://en.wikipedia.org/wiki/Sieve\_of\_Eratosthenes}{this algorithm} to make your function efficient. Name your function \sphinxcode{\sphinxupquote{all\_primes()}} and use the following code to test it

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{all\PYGZus{}primes}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} The body of your function goes here}

\PYG{n}{n} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} }
\PYG{n}{primes} \PYG{o}{=} \PYG{n}{all\PYGZus{}primes}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{primes}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Dealing with files}
\label{\detokenize{placeholder_notebooks/4_Files/4_Files_student:dealing-with-files}}\label{\detokenize{placeholder_notebooks/4_Files/4_Files_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
open files

\item {} 
\sphinxAtStartPar
load data from files

\item {} 
\sphinxAtStartPar
save data to files

\item {} 
\sphinxAtStartPar
format strings

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Not available yet}

\sphinxAtStartPar
This chapter will be made available before the session.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{NumPy}
\label{\detokenize{placeholder_notebooks/5_NumPy/5_NumPy_student:numpy}}\label{\detokenize{placeholder_notebooks/5_NumPy/5_NumPy_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
work with vectors and matrices

\item {} 
\sphinxAtStartPar
do simple linear algebra

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Not available yet}

\sphinxAtStartPar
This chapter will be made available before the session.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Visualization}
\label{\detokenize{placeholder_notebooks/6_Visualization/6_Visualization_student:visualization}}\label{\detokenize{placeholder_notebooks/6_Visualization/6_Visualization_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you should be able to
\begin{itemize}
\item {} 
\sphinxAtStartPar
use the plot command to make simple plots;

\item {} 
\sphinxAtStartPar
know how to use hold on/off

\item {} 
\sphinxAtStartPar
plot several functions in one figure either in one graphical window or by creating a few smaller ones (the use of subplot);

\item {} 
\sphinxAtStartPar
add a title, grid and a legend, describe the axes, change the range of axes;

\item {} 
\sphinxAtStartPar
use logarithmic axes;

\item {} 
\sphinxAtStartPar
make simple 3D line plots;

\item {} 
\sphinxAtStartPar
plot surfaces, contours, change colors;

\item {} 
\sphinxAtStartPar
save figures to files;

\item {} 
\sphinxAtStartPar
optional: make some fancy plots;

\item {} 
\sphinxAtStartPar
optional: create MATLAB animations.

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Not available yet}

\sphinxAtStartPar
This chapter will be made available before the session.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Objects}
\label{\detokenize{placeholder_notebooks/3_Objects/3_Objects_student:objects}}\label{\detokenize{placeholder_notebooks/3_Objects/3_Objects_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
define objects

\item {} 
\sphinxAtStartPar
use subclasses and superclasses

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Not available yet}

\sphinxAtStartPar
This chapter will be made available before the session.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Modules and packages}
\label{\detokenize{placeholder_notebooks/4_ModulesPackages/4_ModulesPackages_student:modules-and-packages}}\label{\detokenize{placeholder_notebooks/4_ModulesPackages/4_ModulesPackages_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
understand what a module is

\item {} 
\sphinxAtStartPar
understand what a package is

\item {} 
\sphinxAtStartPar
import modules and packages in several ways

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Not available yet}

\sphinxAtStartPar
This chapter will be made available before the session.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Data analysis}
\label{\detokenize{placeholder_notebooks/7_DataAnalysis/7_DataAnalysis_student:data-analysis}}\label{\detokenize{placeholder_notebooks/7_DataAnalysis/7_DataAnalysis_student::doc}}
\begin{sphinxadmonition}{note}{Learning goals}

\sphinxAtStartPar
After finishing this chapter, you are expected to
\begin{itemize}
\item {} 
\sphinxAtStartPar
import data in CSV or Excel format

\item {} 
\sphinxAtStartPar
process this data

\item {} 
\sphinxAtStartPar
write data to different file formats

\item {} 
\sphinxAtStartPar
apply simple filters to images

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Not available yet}

\sphinxAtStartPar
This chapter will be made available before the session.
\end{sphinxadmonition}

\sphinxstepscope


\part{Backmatter}

\sphinxstepscope


\chapter{References}
\label{\detokenize{backmatter/references:references}}\label{\detokenize{backmatter/references::doc}}
\sphinxAtStartPar
\sphinxhref{https://pynative.com/python-tuple-exercise-with-solutions/\#h-exercise-1-reverse-the-tuple}{PYnative}

\sphinxAtStartPar
\sphinxhref{https://realpython.com/python-conditional-statements/}{Example if statements from here}

\sphinxstepscope


\chapter{Resources}
\label{\detokenize{backmatter/resources:resources}}\label{\detokenize{backmatter/resources::doc}}
\sphinxAtStartPar
Some useful resources

\sphinxAtStartPar
List of useful Python packages


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numpy}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scipy}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matplotlib}}
&
\sphinxAtStartPar

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}







\renewcommand{\indexname}{Index}
\printindex
\end{document}